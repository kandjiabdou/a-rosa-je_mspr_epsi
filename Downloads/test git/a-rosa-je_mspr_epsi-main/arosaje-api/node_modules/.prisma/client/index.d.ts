
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export interface PrismaPromise<A> extends Promise<A> {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Role
 * 
 */
export type Role = {
  id: number
  nom: string
}

/**
 * Model User
 * 
 */
export type User = {
  id_user: number
  prenom: string | null
  nom: string
  email: string
  telephone: string
  Numero_rue: string | null
  code_postale: string | null
  ville: string | null
  mdp: string | null
  flag: number
}

/**
 * Model Botaniste
 * 
 */
export type Botaniste = {
  user: number
}

/**
 * Model User_lambda
 * 
 */
export type User_lambda = {
  user: number
}

/**
 * Model Annonce
 * 
 */
export type Annonce = {
  id_annonce: number
  localisation: string | null
  description: string | null
  type_gardien: number | null
  nb_signalement: number
  latidute: number
  longitude: number
  id_user: number
}

/**
 * Model Gardiennage
 * 
 */
export type Gardiennage = {
  id_gardiennage: number
  date_debut: Date
  date_fin: Date
  description: string | null
  id_user: number
  idAnnonce: number
}

/**
 * Model PhotoGardiennage
 * 
 */
export type PhotoGardiennage = {
  id_photo: number
  lien: string
  date_photo: Date
  idGardiennage: number
}

/**
 * Model PhotoAnnonce
 * 
 */
export type PhotoAnnonce = {
  id_photo: number
  lien: string
  date_photo: Date
  idAnnonce: number
}

/**
 * Model Conseil
 * 
 */
export type Conseil = {
  id_consiel: number
  date_conseil: Date
  message: string
  idUser: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Roles
 * const roles = await prisma.role.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.botaniste`: Exposes CRUD operations for the **Botaniste** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Botanistes
    * const botanistes = await prisma.botaniste.findMany()
    * ```
    */
  get botaniste(): Prisma.BotanisteDelegate<GlobalReject>;

  /**
   * `prisma.user_lambda`: Exposes CRUD operations for the **User_lambda** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_lambdas
    * const user_lambdas = await prisma.user_lambda.findMany()
    * ```
    */
  get user_lambda(): Prisma.User_lambdaDelegate<GlobalReject>;

  /**
   * `prisma.annonce`: Exposes CRUD operations for the **Annonce** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Annonces
    * const annonces = await prisma.annonce.findMany()
    * ```
    */
  get annonce(): Prisma.AnnonceDelegate<GlobalReject>;

  /**
   * `prisma.gardiennage`: Exposes CRUD operations for the **Gardiennage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gardiennages
    * const gardiennages = await prisma.gardiennage.findMany()
    * ```
    */
  get gardiennage(): Prisma.GardiennageDelegate<GlobalReject>;

  /**
   * `prisma.photoGardiennage`: Exposes CRUD operations for the **PhotoGardiennage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhotoGardiennages
    * const photoGardiennages = await prisma.photoGardiennage.findMany()
    * ```
    */
  get photoGardiennage(): Prisma.PhotoGardiennageDelegate<GlobalReject>;

  /**
   * `prisma.photoAnnonce`: Exposes CRUD operations for the **PhotoAnnonce** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhotoAnnonces
    * const photoAnnonces = await prisma.photoAnnonce.findMany()
    * ```
    */
  get photoAnnonce(): Prisma.PhotoAnnonceDelegate<GlobalReject>;

  /**
   * `prisma.conseil`: Exposes CRUD operations for the **Conseil** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conseils
    * const conseils = await prisma.conseil.findMany()
    * ```
    */
  get conseil(): Prisma.ConseilDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.9.0
   * Query Engine version: ceb5c99003b99c9ee2c1d2e618e359c14aef2ea5
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Role: 'Role',
    User: 'User',
    Botaniste: 'Botaniste',
    User_lambda: 'User_lambda',
    Annonce: 'Annonce',
    Gardiennage: 'Gardiennage',
    PhotoGardiennage: 'PhotoGardiennage',
    PhotoAnnonce: 'PhotoAnnonce',
    Conseil: 'Conseil'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    botanistes: number
    user_lambda: number
    annonces: number
    gardiennages: number
    Conseil: number
  }

  export type UserCountOutputTypeSelect = {
    botanistes?: boolean
    user_lambda?: boolean
    annonces?: boolean
    gardiennages?: boolean
    Conseil?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type AnnonceCountOutputType
   */


  export type AnnonceCountOutputType = {
    photo: number
  }

  export type AnnonceCountOutputTypeSelect = {
    photo?: boolean
  }

  export type AnnonceCountOutputTypeGetPayload<S extends boolean | null | undefined | AnnonceCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AnnonceCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (AnnonceCountOutputTypeArgs)
    ? AnnonceCountOutputType 
    : S extends { select: any } & (AnnonceCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AnnonceCountOutputType ? AnnonceCountOutputType[P] : never
  } 
      : AnnonceCountOutputType




  // Custom InputTypes

  /**
   * AnnonceCountOutputType without action
   */
  export type AnnonceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AnnonceCountOutputType
     */
    select?: AnnonceCountOutputTypeSelect | null
  }



  /**
   * Count Type GardiennageCountOutputType
   */


  export type GardiennageCountOutputType = {
    photo_gardiennage: number
  }

  export type GardiennageCountOutputTypeSelect = {
    photo_gardiennage?: boolean
  }

  export type GardiennageCountOutputTypeGetPayload<S extends boolean | null | undefined | GardiennageCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? GardiennageCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (GardiennageCountOutputTypeArgs)
    ? GardiennageCountOutputType 
    : S extends { select: any } & (GardiennageCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof GardiennageCountOutputType ? GardiennageCountOutputType[P] : never
  } 
      : GardiennageCountOutputType




  // Custom InputTypes

  /**
   * GardiennageCountOutputType without action
   */
  export type GardiennageCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the GardiennageCountOutputType
     */
    select?: GardiennageCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Role
   */


  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    nom: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    nom: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    nom: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    nom?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    nom?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    nom?: true
    _all?: true
  }

  export type RoleAggregateArgs = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs = {
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithAggregationInput>
    by: RoleScalarFieldEnum[]
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }


  export type RoleGroupByOutputType = {
    id: number
    nom: string
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = PrismaPromise<
    Array<
      PickArray<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect = {
    id?: boolean
    user?: boolean | UserArgs
    nom?: boolean
  }


  export type RoleInclude = {
    user?: boolean | UserArgs
  }

  export type RoleGetPayload<S extends boolean | null | undefined | RoleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Role :
    S extends undefined ? never :
    S extends { include: any } & (RoleArgs | RoleFindManyArgs)
    ? Role  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RoleArgs | RoleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Role ? Role[P] : never
  } 
      : Role


  type RoleCountArgs = 
    Omit<RoleFindManyArgs, 'select' | 'include'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Role'> extends True ? Prisma__RoleClient<RoleGetPayload<T>> : Prisma__RoleClient<RoleGetPayload<T> | null, null>

    /**
     * Find one Role that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RoleFindUniqueOrThrowArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Role'> extends True ? Prisma__RoleClient<RoleGetPayload<T>> : Prisma__RoleClient<RoleGetPayload<T> | null, null>

    /**
     * Find the first Role that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoleFindFirstOrThrowArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs>
    ): PrismaPromise<Array<RoleGetPayload<T>>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoleClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Role base type for findUnique actions
   */
  export type RoleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUnique
   */
  export interface RoleFindUniqueArgs extends RoleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role base type for findFirst actions
   */
  export type RoleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: Enumerable<RoleScalarFieldEnum>
  }

  /**
   * Role findFirst
   */
  export interface RoleFindFirstArgs extends RoleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role findMany
   */
  export type RoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role create
   */
  export type RoleCreateArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }


  /**
   * Role update
   */
  export type RoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }


  /**
   * Role upsert
   */
  export type RoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }


  /**
   * Role delete
   */
  export type RoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }


  /**
   * Role without action
   */
  export type RoleArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id_user: number | null
    flag: number | null
  }

  export type UserSumAggregateOutputType = {
    id_user: number | null
    flag: number | null
  }

  export type UserMinAggregateOutputType = {
    id_user: number | null
    prenom: string | null
    nom: string | null
    email: string | null
    telephone: string | null
    Numero_rue: string | null
    code_postale: string | null
    ville: string | null
    mdp: string | null
    flag: number | null
  }

  export type UserMaxAggregateOutputType = {
    id_user: number | null
    prenom: string | null
    nom: string | null
    email: string | null
    telephone: string | null
    Numero_rue: string | null
    code_postale: string | null
    ville: string | null
    mdp: string | null
    flag: number | null
  }

  export type UserCountAggregateOutputType = {
    id_user: number
    prenom: number
    nom: number
    email: number
    telephone: number
    Numero_rue: number
    code_postale: number
    ville: number
    mdp: number
    flag: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id_user?: true
    flag?: true
  }

  export type UserSumAggregateInputType = {
    id_user?: true
    flag?: true
  }

  export type UserMinAggregateInputType = {
    id_user?: true
    prenom?: true
    nom?: true
    email?: true
    telephone?: true
    Numero_rue?: true
    code_postale?: true
    ville?: true
    mdp?: true
    flag?: true
  }

  export type UserMaxAggregateInputType = {
    id_user?: true
    prenom?: true
    nom?: true
    email?: true
    telephone?: true
    Numero_rue?: true
    code_postale?: true
    ville?: true
    mdp?: true
    flag?: true
  }

  export type UserCountAggregateInputType = {
    id_user?: true
    prenom?: true
    nom?: true
    email?: true
    telephone?: true
    Numero_rue?: true
    code_postale?: true
    ville?: true
    mdp?: true
    flag?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id_user: number
    prenom: string | null
    nom: string
    email: string
    telephone: string
    Numero_rue: string | null
    code_postale: string | null
    ville: string | null
    mdp: string | null
    flag: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id_user?: boolean
    prenom?: boolean
    nom?: boolean
    email?: boolean
    telephone?: boolean
    Numero_rue?: boolean
    code_postale?: boolean
    ville?: boolean
    mdp?: boolean
    flag?: boolean
    role?: boolean | RoleArgs
    botanistes?: boolean | User$botanistesArgs
    user_lambda?: boolean | User$user_lambdaArgs
    annonces?: boolean | User$annoncesArgs
    gardiennages?: boolean | User$gardiennagesArgs
    Conseil?: boolean | User$ConseilArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    role?: boolean | RoleArgs
    botanistes?: boolean | User$botanistesArgs
    user_lambda?: boolean | User$user_lambdaArgs
    annonces?: boolean | User$annoncesArgs
    gardiennages?: boolean | User$gardiennagesArgs
    Conseil?: boolean | User$ConseilArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'role' ? RoleGetPayload<S['include'][P]> | null :
        P extends 'botanistes' ? Array < BotanisteGetPayload<S['include'][P]>>  :
        P extends 'user_lambda' ? Array < User_lambdaGetPayload<S['include'][P]>>  :
        P extends 'annonces' ? Array < AnnonceGetPayload<S['include'][P]>>  :
        P extends 'gardiennages' ? Array < GardiennageGetPayload<S['include'][P]>>  :
        P extends 'Conseil' ? Array < ConseilGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'role' ? RoleGetPayload<S['select'][P]> | null :
        P extends 'botanistes' ? Array < BotanisteGetPayload<S['select'][P]>>  :
        P extends 'user_lambda' ? Array < User_lambdaGetPayload<S['select'][P]>>  :
        P extends 'annonces' ? Array < AnnonceGetPayload<S['select'][P]>>  :
        P extends 'gardiennages' ? Array < GardiennageGetPayload<S['select'][P]>>  :
        P extends 'Conseil' ? Array < ConseilGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id_user`
     * const userWithId_userOnly = await prisma.user.findMany({ select: { id_user: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    role<T extends RoleArgs= {}>(args?: Subset<T, RoleArgs>): Prisma__RoleClient<RoleGetPayload<T> | Null>;

    botanistes<T extends User$botanistesArgs= {}>(args?: Subset<T, User$botanistesArgs>): PrismaPromise<Array<BotanisteGetPayload<T>>| Null>;

    user_lambda<T extends User$user_lambdaArgs= {}>(args?: Subset<T, User$user_lambdaArgs>): PrismaPromise<Array<User_lambdaGetPayload<T>>| Null>;

    annonces<T extends User$annoncesArgs= {}>(args?: Subset<T, User$annoncesArgs>): PrismaPromise<Array<AnnonceGetPayload<T>>| Null>;

    gardiennages<T extends User$gardiennagesArgs= {}>(args?: Subset<T, User$gardiennagesArgs>): PrismaPromise<Array<GardiennageGetPayload<T>>| Null>;

    Conseil<T extends User$ConseilArgs= {}>(args?: Subset<T, User$ConseilArgs>): PrismaPromise<Array<ConseilGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.botanistes
   */
  export type User$botanistesArgs = {
    /**
     * Select specific fields to fetch from the Botaniste
     */
    select?: BotanisteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BotanisteInclude | null
    where?: BotanisteWhereInput
    orderBy?: Enumerable<BotanisteOrderByWithRelationInput>
    cursor?: BotanisteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BotanisteScalarFieldEnum>
  }


  /**
   * User.user_lambda
   */
  export type User$user_lambdaArgs = {
    /**
     * Select specific fields to fetch from the User_lambda
     */
    select?: User_lambdaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_lambdaInclude | null
    where?: User_lambdaWhereInput
    orderBy?: Enumerable<User_lambdaOrderByWithRelationInput>
    cursor?: User_lambdaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<User_lambdaScalarFieldEnum>
  }


  /**
   * User.annonces
   */
  export type User$annoncesArgs = {
    /**
     * Select specific fields to fetch from the Annonce
     */
    select?: AnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnonceInclude | null
    where?: AnnonceWhereInput
    orderBy?: Enumerable<AnnonceOrderByWithRelationInput>
    cursor?: AnnonceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AnnonceScalarFieldEnum>
  }


  /**
   * User.gardiennages
   */
  export type User$gardiennagesArgs = {
    /**
     * Select specific fields to fetch from the Gardiennage
     */
    select?: GardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GardiennageInclude | null
    where?: GardiennageWhereInput
    orderBy?: Enumerable<GardiennageOrderByWithRelationInput>
    cursor?: GardiennageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GardiennageScalarFieldEnum>
  }


  /**
   * User.Conseil
   */
  export type User$ConseilArgs = {
    /**
     * Select specific fields to fetch from the Conseil
     */
    select?: ConseilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConseilInclude | null
    where?: ConseilWhereInput
    orderBy?: Enumerable<ConseilOrderByWithRelationInput>
    cursor?: ConseilWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ConseilScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model Botaniste
   */


  export type AggregateBotaniste = {
    _count: BotanisteCountAggregateOutputType | null
    _avg: BotanisteAvgAggregateOutputType | null
    _sum: BotanisteSumAggregateOutputType | null
    _min: BotanisteMinAggregateOutputType | null
    _max: BotanisteMaxAggregateOutputType | null
  }

  export type BotanisteAvgAggregateOutputType = {
    user: number | null
  }

  export type BotanisteSumAggregateOutputType = {
    user: number | null
  }

  export type BotanisteMinAggregateOutputType = {
    user: number | null
  }

  export type BotanisteMaxAggregateOutputType = {
    user: number | null
  }

  export type BotanisteCountAggregateOutputType = {
    user: number
    _all: number
  }


  export type BotanisteAvgAggregateInputType = {
    user?: true
  }

  export type BotanisteSumAggregateInputType = {
    user?: true
  }

  export type BotanisteMinAggregateInputType = {
    user?: true
  }

  export type BotanisteMaxAggregateInputType = {
    user?: true
  }

  export type BotanisteCountAggregateInputType = {
    user?: true
    _all?: true
  }

  export type BotanisteAggregateArgs = {
    /**
     * Filter which Botaniste to aggregate.
     */
    where?: BotanisteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Botanistes to fetch.
     */
    orderBy?: Enumerable<BotanisteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BotanisteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Botanistes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Botanistes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Botanistes
    **/
    _count?: true | BotanisteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BotanisteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BotanisteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BotanisteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BotanisteMaxAggregateInputType
  }

  export type GetBotanisteAggregateType<T extends BotanisteAggregateArgs> = {
        [P in keyof T & keyof AggregateBotaniste]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBotaniste[P]>
      : GetScalarType<T[P], AggregateBotaniste[P]>
  }




  export type BotanisteGroupByArgs = {
    where?: BotanisteWhereInput
    orderBy?: Enumerable<BotanisteOrderByWithAggregationInput>
    by: BotanisteScalarFieldEnum[]
    having?: BotanisteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BotanisteCountAggregateInputType | true
    _avg?: BotanisteAvgAggregateInputType
    _sum?: BotanisteSumAggregateInputType
    _min?: BotanisteMinAggregateInputType
    _max?: BotanisteMaxAggregateInputType
  }


  export type BotanisteGroupByOutputType = {
    user: number
    _count: BotanisteCountAggregateOutputType | null
    _avg: BotanisteAvgAggregateOutputType | null
    _sum: BotanisteSumAggregateOutputType | null
    _min: BotanisteMinAggregateOutputType | null
    _max: BotanisteMaxAggregateOutputType | null
  }

  type GetBotanisteGroupByPayload<T extends BotanisteGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BotanisteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BotanisteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BotanisteGroupByOutputType[P]>
            : GetScalarType<T[P], BotanisteGroupByOutputType[P]>
        }
      >
    >


  export type BotanisteSelect = {
    user?: boolean
    id_user?: boolean | UserArgs
  }


  export type BotanisteInclude = {
    id_user?: boolean | UserArgs
  }

  export type BotanisteGetPayload<S extends boolean | null | undefined | BotanisteArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Botaniste :
    S extends undefined ? never :
    S extends { include: any } & (BotanisteArgs | BotanisteFindManyArgs)
    ? Botaniste  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'id_user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BotanisteArgs | BotanisteFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'id_user' ? UserGetPayload<S['select'][P]> :  P extends keyof Botaniste ? Botaniste[P] : never
  } 
      : Botaniste


  type BotanisteCountArgs = 
    Omit<BotanisteFindManyArgs, 'select' | 'include'> & {
      select?: BotanisteCountAggregateInputType | true
    }

  export interface BotanisteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Botaniste that matches the filter.
     * @param {BotanisteFindUniqueArgs} args - Arguments to find a Botaniste
     * @example
     * // Get one Botaniste
     * const botaniste = await prisma.botaniste.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BotanisteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BotanisteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Botaniste'> extends True ? Prisma__BotanisteClient<BotanisteGetPayload<T>> : Prisma__BotanisteClient<BotanisteGetPayload<T> | null, null>

    /**
     * Find one Botaniste that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BotanisteFindUniqueOrThrowArgs} args - Arguments to find a Botaniste
     * @example
     * // Get one Botaniste
     * const botaniste = await prisma.botaniste.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BotanisteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BotanisteFindUniqueOrThrowArgs>
    ): Prisma__BotanisteClient<BotanisteGetPayload<T>>

    /**
     * Find the first Botaniste that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotanisteFindFirstArgs} args - Arguments to find a Botaniste
     * @example
     * // Get one Botaniste
     * const botaniste = await prisma.botaniste.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BotanisteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BotanisteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Botaniste'> extends True ? Prisma__BotanisteClient<BotanisteGetPayload<T>> : Prisma__BotanisteClient<BotanisteGetPayload<T> | null, null>

    /**
     * Find the first Botaniste that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotanisteFindFirstOrThrowArgs} args - Arguments to find a Botaniste
     * @example
     * // Get one Botaniste
     * const botaniste = await prisma.botaniste.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BotanisteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BotanisteFindFirstOrThrowArgs>
    ): Prisma__BotanisteClient<BotanisteGetPayload<T>>

    /**
     * Find zero or more Botanistes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotanisteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Botanistes
     * const botanistes = await prisma.botaniste.findMany()
     * 
     * // Get first 10 Botanistes
     * const botanistes = await prisma.botaniste.findMany({ take: 10 })
     * 
     * // Only select the `user`
     * const botanisteWithUserOnly = await prisma.botaniste.findMany({ select: { user: true } })
     * 
    **/
    findMany<T extends BotanisteFindManyArgs>(
      args?: SelectSubset<T, BotanisteFindManyArgs>
    ): PrismaPromise<Array<BotanisteGetPayload<T>>>

    /**
     * Create a Botaniste.
     * @param {BotanisteCreateArgs} args - Arguments to create a Botaniste.
     * @example
     * // Create one Botaniste
     * const Botaniste = await prisma.botaniste.create({
     *   data: {
     *     // ... data to create a Botaniste
     *   }
     * })
     * 
    **/
    create<T extends BotanisteCreateArgs>(
      args: SelectSubset<T, BotanisteCreateArgs>
    ): Prisma__BotanisteClient<BotanisteGetPayload<T>>

    /**
     * Delete a Botaniste.
     * @param {BotanisteDeleteArgs} args - Arguments to delete one Botaniste.
     * @example
     * // Delete one Botaniste
     * const Botaniste = await prisma.botaniste.delete({
     *   where: {
     *     // ... filter to delete one Botaniste
     *   }
     * })
     * 
    **/
    delete<T extends BotanisteDeleteArgs>(
      args: SelectSubset<T, BotanisteDeleteArgs>
    ): Prisma__BotanisteClient<BotanisteGetPayload<T>>

    /**
     * Update one Botaniste.
     * @param {BotanisteUpdateArgs} args - Arguments to update one Botaniste.
     * @example
     * // Update one Botaniste
     * const botaniste = await prisma.botaniste.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BotanisteUpdateArgs>(
      args: SelectSubset<T, BotanisteUpdateArgs>
    ): Prisma__BotanisteClient<BotanisteGetPayload<T>>

    /**
     * Delete zero or more Botanistes.
     * @param {BotanisteDeleteManyArgs} args - Arguments to filter Botanistes to delete.
     * @example
     * // Delete a few Botanistes
     * const { count } = await prisma.botaniste.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BotanisteDeleteManyArgs>(
      args?: SelectSubset<T, BotanisteDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Botanistes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotanisteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Botanistes
     * const botaniste = await prisma.botaniste.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BotanisteUpdateManyArgs>(
      args: SelectSubset<T, BotanisteUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Botaniste.
     * @param {BotanisteUpsertArgs} args - Arguments to update or create a Botaniste.
     * @example
     * // Update or create a Botaniste
     * const botaniste = await prisma.botaniste.upsert({
     *   create: {
     *     // ... data to create a Botaniste
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Botaniste we want to update
     *   }
     * })
    **/
    upsert<T extends BotanisteUpsertArgs>(
      args: SelectSubset<T, BotanisteUpsertArgs>
    ): Prisma__BotanisteClient<BotanisteGetPayload<T>>

    /**
     * Count the number of Botanistes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotanisteCountArgs} args - Arguments to filter Botanistes to count.
     * @example
     * // Count the number of Botanistes
     * const count = await prisma.botaniste.count({
     *   where: {
     *     // ... the filter for the Botanistes we want to count
     *   }
     * })
    **/
    count<T extends BotanisteCountArgs>(
      args?: Subset<T, BotanisteCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotanisteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Botaniste.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotanisteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotanisteAggregateArgs>(args: Subset<T, BotanisteAggregateArgs>): PrismaPromise<GetBotanisteAggregateType<T>>

    /**
     * Group by Botaniste.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotanisteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BotanisteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BotanisteGroupByArgs['orderBy'] }
        : { orderBy?: BotanisteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BotanisteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBotanisteGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Botaniste.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BotanisteClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    id_user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Botaniste base type for findUnique actions
   */
  export type BotanisteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Botaniste
     */
    select?: BotanisteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BotanisteInclude | null
    /**
     * Filter, which Botaniste to fetch.
     */
    where: BotanisteWhereUniqueInput
  }

  /**
   * Botaniste findUnique
   */
  export interface BotanisteFindUniqueArgs extends BotanisteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Botaniste findUniqueOrThrow
   */
  export type BotanisteFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Botaniste
     */
    select?: BotanisteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BotanisteInclude | null
    /**
     * Filter, which Botaniste to fetch.
     */
    where: BotanisteWhereUniqueInput
  }


  /**
   * Botaniste base type for findFirst actions
   */
  export type BotanisteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Botaniste
     */
    select?: BotanisteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BotanisteInclude | null
    /**
     * Filter, which Botaniste to fetch.
     */
    where?: BotanisteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Botanistes to fetch.
     */
    orderBy?: Enumerable<BotanisteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Botanistes.
     */
    cursor?: BotanisteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Botanistes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Botanistes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Botanistes.
     */
    distinct?: Enumerable<BotanisteScalarFieldEnum>
  }

  /**
   * Botaniste findFirst
   */
  export interface BotanisteFindFirstArgs extends BotanisteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Botaniste findFirstOrThrow
   */
  export type BotanisteFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Botaniste
     */
    select?: BotanisteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BotanisteInclude | null
    /**
     * Filter, which Botaniste to fetch.
     */
    where?: BotanisteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Botanistes to fetch.
     */
    orderBy?: Enumerable<BotanisteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Botanistes.
     */
    cursor?: BotanisteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Botanistes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Botanistes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Botanistes.
     */
    distinct?: Enumerable<BotanisteScalarFieldEnum>
  }


  /**
   * Botaniste findMany
   */
  export type BotanisteFindManyArgs = {
    /**
     * Select specific fields to fetch from the Botaniste
     */
    select?: BotanisteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BotanisteInclude | null
    /**
     * Filter, which Botanistes to fetch.
     */
    where?: BotanisteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Botanistes to fetch.
     */
    orderBy?: Enumerable<BotanisteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Botanistes.
     */
    cursor?: BotanisteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Botanistes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Botanistes.
     */
    skip?: number
    distinct?: Enumerable<BotanisteScalarFieldEnum>
  }


  /**
   * Botaniste create
   */
  export type BotanisteCreateArgs = {
    /**
     * Select specific fields to fetch from the Botaniste
     */
    select?: BotanisteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BotanisteInclude | null
    /**
     * The data needed to create a Botaniste.
     */
    data: XOR<BotanisteCreateInput, BotanisteUncheckedCreateInput>
  }


  /**
   * Botaniste update
   */
  export type BotanisteUpdateArgs = {
    /**
     * Select specific fields to fetch from the Botaniste
     */
    select?: BotanisteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BotanisteInclude | null
    /**
     * The data needed to update a Botaniste.
     */
    data: XOR<BotanisteUpdateInput, BotanisteUncheckedUpdateInput>
    /**
     * Choose, which Botaniste to update.
     */
    where: BotanisteWhereUniqueInput
  }


  /**
   * Botaniste updateMany
   */
  export type BotanisteUpdateManyArgs = {
    /**
     * The data used to update Botanistes.
     */
    data: XOR<BotanisteUpdateManyMutationInput, BotanisteUncheckedUpdateManyInput>
    /**
     * Filter which Botanistes to update
     */
    where?: BotanisteWhereInput
  }


  /**
   * Botaniste upsert
   */
  export type BotanisteUpsertArgs = {
    /**
     * Select specific fields to fetch from the Botaniste
     */
    select?: BotanisteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BotanisteInclude | null
    /**
     * The filter to search for the Botaniste to update in case it exists.
     */
    where: BotanisteWhereUniqueInput
    /**
     * In case the Botaniste found by the `where` argument doesn't exist, create a new Botaniste with this data.
     */
    create: XOR<BotanisteCreateInput, BotanisteUncheckedCreateInput>
    /**
     * In case the Botaniste was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BotanisteUpdateInput, BotanisteUncheckedUpdateInput>
  }


  /**
   * Botaniste delete
   */
  export type BotanisteDeleteArgs = {
    /**
     * Select specific fields to fetch from the Botaniste
     */
    select?: BotanisteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BotanisteInclude | null
    /**
     * Filter which Botaniste to delete.
     */
    where: BotanisteWhereUniqueInput
  }


  /**
   * Botaniste deleteMany
   */
  export type BotanisteDeleteManyArgs = {
    /**
     * Filter which Botanistes to delete
     */
    where?: BotanisteWhereInput
  }


  /**
   * Botaniste without action
   */
  export type BotanisteArgs = {
    /**
     * Select specific fields to fetch from the Botaniste
     */
    select?: BotanisteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BotanisteInclude | null
  }



  /**
   * Model User_lambda
   */


  export type AggregateUser_lambda = {
    _count: User_lambdaCountAggregateOutputType | null
    _avg: User_lambdaAvgAggregateOutputType | null
    _sum: User_lambdaSumAggregateOutputType | null
    _min: User_lambdaMinAggregateOutputType | null
    _max: User_lambdaMaxAggregateOutputType | null
  }

  export type User_lambdaAvgAggregateOutputType = {
    user: number | null
  }

  export type User_lambdaSumAggregateOutputType = {
    user: number | null
  }

  export type User_lambdaMinAggregateOutputType = {
    user: number | null
  }

  export type User_lambdaMaxAggregateOutputType = {
    user: number | null
  }

  export type User_lambdaCountAggregateOutputType = {
    user: number
    _all: number
  }


  export type User_lambdaAvgAggregateInputType = {
    user?: true
  }

  export type User_lambdaSumAggregateInputType = {
    user?: true
  }

  export type User_lambdaMinAggregateInputType = {
    user?: true
  }

  export type User_lambdaMaxAggregateInputType = {
    user?: true
  }

  export type User_lambdaCountAggregateInputType = {
    user?: true
    _all?: true
  }

  export type User_lambdaAggregateArgs = {
    /**
     * Filter which User_lambda to aggregate.
     */
    where?: User_lambdaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_lambdas to fetch.
     */
    orderBy?: Enumerable<User_lambdaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: User_lambdaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_lambdas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_lambdas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned User_lambdas
    **/
    _count?: true | User_lambdaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_lambdaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_lambdaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_lambdaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_lambdaMaxAggregateInputType
  }

  export type GetUser_lambdaAggregateType<T extends User_lambdaAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_lambda]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_lambda[P]>
      : GetScalarType<T[P], AggregateUser_lambda[P]>
  }




  export type User_lambdaGroupByArgs = {
    where?: User_lambdaWhereInput
    orderBy?: Enumerable<User_lambdaOrderByWithAggregationInput>
    by: User_lambdaScalarFieldEnum[]
    having?: User_lambdaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_lambdaCountAggregateInputType | true
    _avg?: User_lambdaAvgAggregateInputType
    _sum?: User_lambdaSumAggregateInputType
    _min?: User_lambdaMinAggregateInputType
    _max?: User_lambdaMaxAggregateInputType
  }


  export type User_lambdaGroupByOutputType = {
    user: number
    _count: User_lambdaCountAggregateOutputType | null
    _avg: User_lambdaAvgAggregateOutputType | null
    _sum: User_lambdaSumAggregateOutputType | null
    _min: User_lambdaMinAggregateOutputType | null
    _max: User_lambdaMaxAggregateOutputType | null
  }

  type GetUser_lambdaGroupByPayload<T extends User_lambdaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<User_lambdaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_lambdaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_lambdaGroupByOutputType[P]>
            : GetScalarType<T[P], User_lambdaGroupByOutputType[P]>
        }
      >
    >


  export type User_lambdaSelect = {
    user?: boolean
    id_user?: boolean | UserArgs
  }


  export type User_lambdaInclude = {
    id_user?: boolean | UserArgs
  }

  export type User_lambdaGetPayload<S extends boolean | null | undefined | User_lambdaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User_lambda :
    S extends undefined ? never :
    S extends { include: any } & (User_lambdaArgs | User_lambdaFindManyArgs)
    ? User_lambda  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'id_user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (User_lambdaArgs | User_lambdaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'id_user' ? UserGetPayload<S['select'][P]> :  P extends keyof User_lambda ? User_lambda[P] : never
  } 
      : User_lambda


  type User_lambdaCountArgs = 
    Omit<User_lambdaFindManyArgs, 'select' | 'include'> & {
      select?: User_lambdaCountAggregateInputType | true
    }

  export interface User_lambdaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User_lambda that matches the filter.
     * @param {User_lambdaFindUniqueArgs} args - Arguments to find a User_lambda
     * @example
     * // Get one User_lambda
     * const user_lambda = await prisma.user_lambda.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends User_lambdaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, User_lambdaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User_lambda'> extends True ? Prisma__User_lambdaClient<User_lambdaGetPayload<T>> : Prisma__User_lambdaClient<User_lambdaGetPayload<T> | null, null>

    /**
     * Find one User_lambda that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {User_lambdaFindUniqueOrThrowArgs} args - Arguments to find a User_lambda
     * @example
     * // Get one User_lambda
     * const user_lambda = await prisma.user_lambda.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends User_lambdaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, User_lambdaFindUniqueOrThrowArgs>
    ): Prisma__User_lambdaClient<User_lambdaGetPayload<T>>

    /**
     * Find the first User_lambda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_lambdaFindFirstArgs} args - Arguments to find a User_lambda
     * @example
     * // Get one User_lambda
     * const user_lambda = await prisma.user_lambda.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends User_lambdaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, User_lambdaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User_lambda'> extends True ? Prisma__User_lambdaClient<User_lambdaGetPayload<T>> : Prisma__User_lambdaClient<User_lambdaGetPayload<T> | null, null>

    /**
     * Find the first User_lambda that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_lambdaFindFirstOrThrowArgs} args - Arguments to find a User_lambda
     * @example
     * // Get one User_lambda
     * const user_lambda = await prisma.user_lambda.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends User_lambdaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, User_lambdaFindFirstOrThrowArgs>
    ): Prisma__User_lambdaClient<User_lambdaGetPayload<T>>

    /**
     * Find zero or more User_lambdas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_lambdaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_lambdas
     * const user_lambdas = await prisma.user_lambda.findMany()
     * 
     * // Get first 10 User_lambdas
     * const user_lambdas = await prisma.user_lambda.findMany({ take: 10 })
     * 
     * // Only select the `user`
     * const user_lambdaWithUserOnly = await prisma.user_lambda.findMany({ select: { user: true } })
     * 
    **/
    findMany<T extends User_lambdaFindManyArgs>(
      args?: SelectSubset<T, User_lambdaFindManyArgs>
    ): PrismaPromise<Array<User_lambdaGetPayload<T>>>

    /**
     * Create a User_lambda.
     * @param {User_lambdaCreateArgs} args - Arguments to create a User_lambda.
     * @example
     * // Create one User_lambda
     * const User_lambda = await prisma.user_lambda.create({
     *   data: {
     *     // ... data to create a User_lambda
     *   }
     * })
     * 
    **/
    create<T extends User_lambdaCreateArgs>(
      args: SelectSubset<T, User_lambdaCreateArgs>
    ): Prisma__User_lambdaClient<User_lambdaGetPayload<T>>

    /**
     * Delete a User_lambda.
     * @param {User_lambdaDeleteArgs} args - Arguments to delete one User_lambda.
     * @example
     * // Delete one User_lambda
     * const User_lambda = await prisma.user_lambda.delete({
     *   where: {
     *     // ... filter to delete one User_lambda
     *   }
     * })
     * 
    **/
    delete<T extends User_lambdaDeleteArgs>(
      args: SelectSubset<T, User_lambdaDeleteArgs>
    ): Prisma__User_lambdaClient<User_lambdaGetPayload<T>>

    /**
     * Update one User_lambda.
     * @param {User_lambdaUpdateArgs} args - Arguments to update one User_lambda.
     * @example
     * // Update one User_lambda
     * const user_lambda = await prisma.user_lambda.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends User_lambdaUpdateArgs>(
      args: SelectSubset<T, User_lambdaUpdateArgs>
    ): Prisma__User_lambdaClient<User_lambdaGetPayload<T>>

    /**
     * Delete zero or more User_lambdas.
     * @param {User_lambdaDeleteManyArgs} args - Arguments to filter User_lambdas to delete.
     * @example
     * // Delete a few User_lambdas
     * const { count } = await prisma.user_lambda.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends User_lambdaDeleteManyArgs>(
      args?: SelectSubset<T, User_lambdaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_lambdas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_lambdaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_lambdas
     * const user_lambda = await prisma.user_lambda.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends User_lambdaUpdateManyArgs>(
      args: SelectSubset<T, User_lambdaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User_lambda.
     * @param {User_lambdaUpsertArgs} args - Arguments to update or create a User_lambda.
     * @example
     * // Update or create a User_lambda
     * const user_lambda = await prisma.user_lambda.upsert({
     *   create: {
     *     // ... data to create a User_lambda
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_lambda we want to update
     *   }
     * })
    **/
    upsert<T extends User_lambdaUpsertArgs>(
      args: SelectSubset<T, User_lambdaUpsertArgs>
    ): Prisma__User_lambdaClient<User_lambdaGetPayload<T>>

    /**
     * Count the number of User_lambdas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_lambdaCountArgs} args - Arguments to filter User_lambdas to count.
     * @example
     * // Count the number of User_lambdas
     * const count = await prisma.user_lambda.count({
     *   where: {
     *     // ... the filter for the User_lambdas we want to count
     *   }
     * })
    **/
    count<T extends User_lambdaCountArgs>(
      args?: Subset<T, User_lambdaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_lambdaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_lambda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_lambdaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_lambdaAggregateArgs>(args: Subset<T, User_lambdaAggregateArgs>): PrismaPromise<GetUser_lambdaAggregateType<T>>

    /**
     * Group by User_lambda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_lambdaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_lambdaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_lambdaGroupByArgs['orderBy'] }
        : { orderBy?: User_lambdaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_lambdaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_lambdaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User_lambda.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__User_lambdaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    id_user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User_lambda base type for findUnique actions
   */
  export type User_lambdaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User_lambda
     */
    select?: User_lambdaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_lambdaInclude | null
    /**
     * Filter, which User_lambda to fetch.
     */
    where: User_lambdaWhereUniqueInput
  }

  /**
   * User_lambda findUnique
   */
  export interface User_lambdaFindUniqueArgs extends User_lambdaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User_lambda findUniqueOrThrow
   */
  export type User_lambdaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User_lambda
     */
    select?: User_lambdaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_lambdaInclude | null
    /**
     * Filter, which User_lambda to fetch.
     */
    where: User_lambdaWhereUniqueInput
  }


  /**
   * User_lambda base type for findFirst actions
   */
  export type User_lambdaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User_lambda
     */
    select?: User_lambdaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_lambdaInclude | null
    /**
     * Filter, which User_lambda to fetch.
     */
    where?: User_lambdaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_lambdas to fetch.
     */
    orderBy?: Enumerable<User_lambdaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for User_lambdas.
     */
    cursor?: User_lambdaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_lambdas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_lambdas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of User_lambdas.
     */
    distinct?: Enumerable<User_lambdaScalarFieldEnum>
  }

  /**
   * User_lambda findFirst
   */
  export interface User_lambdaFindFirstArgs extends User_lambdaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User_lambda findFirstOrThrow
   */
  export type User_lambdaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User_lambda
     */
    select?: User_lambdaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_lambdaInclude | null
    /**
     * Filter, which User_lambda to fetch.
     */
    where?: User_lambdaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_lambdas to fetch.
     */
    orderBy?: Enumerable<User_lambdaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for User_lambdas.
     */
    cursor?: User_lambdaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_lambdas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_lambdas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of User_lambdas.
     */
    distinct?: Enumerable<User_lambdaScalarFieldEnum>
  }


  /**
   * User_lambda findMany
   */
  export type User_lambdaFindManyArgs = {
    /**
     * Select specific fields to fetch from the User_lambda
     */
    select?: User_lambdaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_lambdaInclude | null
    /**
     * Filter, which User_lambdas to fetch.
     */
    where?: User_lambdaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of User_lambdas to fetch.
     */
    orderBy?: Enumerable<User_lambdaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing User_lambdas.
     */
    cursor?: User_lambdaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` User_lambdas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` User_lambdas.
     */
    skip?: number
    distinct?: Enumerable<User_lambdaScalarFieldEnum>
  }


  /**
   * User_lambda create
   */
  export type User_lambdaCreateArgs = {
    /**
     * Select specific fields to fetch from the User_lambda
     */
    select?: User_lambdaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_lambdaInclude | null
    /**
     * The data needed to create a User_lambda.
     */
    data: XOR<User_lambdaCreateInput, User_lambdaUncheckedCreateInput>
  }


  /**
   * User_lambda update
   */
  export type User_lambdaUpdateArgs = {
    /**
     * Select specific fields to fetch from the User_lambda
     */
    select?: User_lambdaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_lambdaInclude | null
    /**
     * The data needed to update a User_lambda.
     */
    data: XOR<User_lambdaUpdateInput, User_lambdaUncheckedUpdateInput>
    /**
     * Choose, which User_lambda to update.
     */
    where: User_lambdaWhereUniqueInput
  }


  /**
   * User_lambda updateMany
   */
  export type User_lambdaUpdateManyArgs = {
    /**
     * The data used to update User_lambdas.
     */
    data: XOR<User_lambdaUpdateManyMutationInput, User_lambdaUncheckedUpdateManyInput>
    /**
     * Filter which User_lambdas to update
     */
    where?: User_lambdaWhereInput
  }


  /**
   * User_lambda upsert
   */
  export type User_lambdaUpsertArgs = {
    /**
     * Select specific fields to fetch from the User_lambda
     */
    select?: User_lambdaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_lambdaInclude | null
    /**
     * The filter to search for the User_lambda to update in case it exists.
     */
    where: User_lambdaWhereUniqueInput
    /**
     * In case the User_lambda found by the `where` argument doesn't exist, create a new User_lambda with this data.
     */
    create: XOR<User_lambdaCreateInput, User_lambdaUncheckedCreateInput>
    /**
     * In case the User_lambda was found with the provided `where` argument, update it with this data.
     */
    update: XOR<User_lambdaUpdateInput, User_lambdaUncheckedUpdateInput>
  }


  /**
   * User_lambda delete
   */
  export type User_lambdaDeleteArgs = {
    /**
     * Select specific fields to fetch from the User_lambda
     */
    select?: User_lambdaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_lambdaInclude | null
    /**
     * Filter which User_lambda to delete.
     */
    where: User_lambdaWhereUniqueInput
  }


  /**
   * User_lambda deleteMany
   */
  export type User_lambdaDeleteManyArgs = {
    /**
     * Filter which User_lambdas to delete
     */
    where?: User_lambdaWhereInput
  }


  /**
   * User_lambda without action
   */
  export type User_lambdaArgs = {
    /**
     * Select specific fields to fetch from the User_lambda
     */
    select?: User_lambdaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: User_lambdaInclude | null
  }



  /**
   * Model Annonce
   */


  export type AggregateAnnonce = {
    _count: AnnonceCountAggregateOutputType | null
    _avg: AnnonceAvgAggregateOutputType | null
    _sum: AnnonceSumAggregateOutputType | null
    _min: AnnonceMinAggregateOutputType | null
    _max: AnnonceMaxAggregateOutputType | null
  }

  export type AnnonceAvgAggregateOutputType = {
    id_annonce: number | null
    type_gardien: number | null
    nb_signalement: number | null
    latidute: number | null
    longitude: number | null
    id_user: number | null
  }

  export type AnnonceSumAggregateOutputType = {
    id_annonce: number | null
    type_gardien: number | null
    nb_signalement: number | null
    latidute: number | null
    longitude: number | null
    id_user: number | null
  }

  export type AnnonceMinAggregateOutputType = {
    id_annonce: number | null
    localisation: string | null
    description: string | null
    type_gardien: number | null
    nb_signalement: number | null
    latidute: number | null
    longitude: number | null
    id_user: number | null
  }

  export type AnnonceMaxAggregateOutputType = {
    id_annonce: number | null
    localisation: string | null
    description: string | null
    type_gardien: number | null
    nb_signalement: number | null
    latidute: number | null
    longitude: number | null
    id_user: number | null
  }

  export type AnnonceCountAggregateOutputType = {
    id_annonce: number
    localisation: number
    description: number
    type_gardien: number
    nb_signalement: number
    latidute: number
    longitude: number
    id_user: number
    _all: number
  }


  export type AnnonceAvgAggregateInputType = {
    id_annonce?: true
    type_gardien?: true
    nb_signalement?: true
    latidute?: true
    longitude?: true
    id_user?: true
  }

  export type AnnonceSumAggregateInputType = {
    id_annonce?: true
    type_gardien?: true
    nb_signalement?: true
    latidute?: true
    longitude?: true
    id_user?: true
  }

  export type AnnonceMinAggregateInputType = {
    id_annonce?: true
    localisation?: true
    description?: true
    type_gardien?: true
    nb_signalement?: true
    latidute?: true
    longitude?: true
    id_user?: true
  }

  export type AnnonceMaxAggregateInputType = {
    id_annonce?: true
    localisation?: true
    description?: true
    type_gardien?: true
    nb_signalement?: true
    latidute?: true
    longitude?: true
    id_user?: true
  }

  export type AnnonceCountAggregateInputType = {
    id_annonce?: true
    localisation?: true
    description?: true
    type_gardien?: true
    nb_signalement?: true
    latidute?: true
    longitude?: true
    id_user?: true
    _all?: true
  }

  export type AnnonceAggregateArgs = {
    /**
     * Filter which Annonce to aggregate.
     */
    where?: AnnonceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annonces to fetch.
     */
    orderBy?: Enumerable<AnnonceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnonceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annonces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annonces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Annonces
    **/
    _count?: true | AnnonceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnnonceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnnonceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnonceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnonceMaxAggregateInputType
  }

  export type GetAnnonceAggregateType<T extends AnnonceAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnonce]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnonce[P]>
      : GetScalarType<T[P], AggregateAnnonce[P]>
  }




  export type AnnonceGroupByArgs = {
    where?: AnnonceWhereInput
    orderBy?: Enumerable<AnnonceOrderByWithAggregationInput>
    by: AnnonceScalarFieldEnum[]
    having?: AnnonceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnonceCountAggregateInputType | true
    _avg?: AnnonceAvgAggregateInputType
    _sum?: AnnonceSumAggregateInputType
    _min?: AnnonceMinAggregateInputType
    _max?: AnnonceMaxAggregateInputType
  }


  export type AnnonceGroupByOutputType = {
    id_annonce: number
    localisation: string | null
    description: string | null
    type_gardien: number | null
    nb_signalement: number
    latidute: number
    longitude: number
    id_user: number
    _count: AnnonceCountAggregateOutputType | null
    _avg: AnnonceAvgAggregateOutputType | null
    _sum: AnnonceSumAggregateOutputType | null
    _min: AnnonceMinAggregateOutputType | null
    _max: AnnonceMaxAggregateOutputType | null
  }

  type GetAnnonceGroupByPayload<T extends AnnonceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AnnonceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnonceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnonceGroupByOutputType[P]>
            : GetScalarType<T[P], AnnonceGroupByOutputType[P]>
        }
      >
    >


  export type AnnonceSelect = {
    id_annonce?: boolean
    localisation?: boolean
    description?: boolean
    type_gardien?: boolean
    nb_signalement?: boolean
    latidute?: boolean
    longitude?: boolean
    id_user?: boolean
    user?: boolean | UserArgs
    gardiennage?: boolean | GardiennageArgs
    photo?: boolean | Annonce$photoArgs
    _count?: boolean | AnnonceCountOutputTypeArgs
  }


  export type AnnonceInclude = {
    user?: boolean | UserArgs
    gardiennage?: boolean | GardiennageArgs
    photo?: boolean | Annonce$photoArgs
    _count?: boolean | AnnonceCountOutputTypeArgs
  }

  export type AnnonceGetPayload<S extends boolean | null | undefined | AnnonceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Annonce :
    S extends undefined ? never :
    S extends { include: any } & (AnnonceArgs | AnnonceFindManyArgs)
    ? Annonce  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'gardiennage' ? GardiennageGetPayload<S['include'][P]> | null :
        P extends 'photo' ? Array < PhotoAnnonceGetPayload<S['include'][P]>>  :
        P extends '_count' ? AnnonceCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AnnonceArgs | AnnonceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'gardiennage' ? GardiennageGetPayload<S['select'][P]> | null :
        P extends 'photo' ? Array < PhotoAnnonceGetPayload<S['select'][P]>>  :
        P extends '_count' ? AnnonceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Annonce ? Annonce[P] : never
  } 
      : Annonce


  type AnnonceCountArgs = 
    Omit<AnnonceFindManyArgs, 'select' | 'include'> & {
      select?: AnnonceCountAggregateInputType | true
    }

  export interface AnnonceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Annonce that matches the filter.
     * @param {AnnonceFindUniqueArgs} args - Arguments to find a Annonce
     * @example
     * // Get one Annonce
     * const annonce = await prisma.annonce.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AnnonceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AnnonceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Annonce'> extends True ? Prisma__AnnonceClient<AnnonceGetPayload<T>> : Prisma__AnnonceClient<AnnonceGetPayload<T> | null, null>

    /**
     * Find one Annonce that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AnnonceFindUniqueOrThrowArgs} args - Arguments to find a Annonce
     * @example
     * // Get one Annonce
     * const annonce = await prisma.annonce.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AnnonceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AnnonceFindUniqueOrThrowArgs>
    ): Prisma__AnnonceClient<AnnonceGetPayload<T>>

    /**
     * Find the first Annonce that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnonceFindFirstArgs} args - Arguments to find a Annonce
     * @example
     * // Get one Annonce
     * const annonce = await prisma.annonce.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AnnonceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AnnonceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Annonce'> extends True ? Prisma__AnnonceClient<AnnonceGetPayload<T>> : Prisma__AnnonceClient<AnnonceGetPayload<T> | null, null>

    /**
     * Find the first Annonce that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnonceFindFirstOrThrowArgs} args - Arguments to find a Annonce
     * @example
     * // Get one Annonce
     * const annonce = await prisma.annonce.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AnnonceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AnnonceFindFirstOrThrowArgs>
    ): Prisma__AnnonceClient<AnnonceGetPayload<T>>

    /**
     * Find zero or more Annonces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnonceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Annonces
     * const annonces = await prisma.annonce.findMany()
     * 
     * // Get first 10 Annonces
     * const annonces = await prisma.annonce.findMany({ take: 10 })
     * 
     * // Only select the `id_annonce`
     * const annonceWithId_annonceOnly = await prisma.annonce.findMany({ select: { id_annonce: true } })
     * 
    **/
    findMany<T extends AnnonceFindManyArgs>(
      args?: SelectSubset<T, AnnonceFindManyArgs>
    ): PrismaPromise<Array<AnnonceGetPayload<T>>>

    /**
     * Create a Annonce.
     * @param {AnnonceCreateArgs} args - Arguments to create a Annonce.
     * @example
     * // Create one Annonce
     * const Annonce = await prisma.annonce.create({
     *   data: {
     *     // ... data to create a Annonce
     *   }
     * })
     * 
    **/
    create<T extends AnnonceCreateArgs>(
      args: SelectSubset<T, AnnonceCreateArgs>
    ): Prisma__AnnonceClient<AnnonceGetPayload<T>>

    /**
     * Delete a Annonce.
     * @param {AnnonceDeleteArgs} args - Arguments to delete one Annonce.
     * @example
     * // Delete one Annonce
     * const Annonce = await prisma.annonce.delete({
     *   where: {
     *     // ... filter to delete one Annonce
     *   }
     * })
     * 
    **/
    delete<T extends AnnonceDeleteArgs>(
      args: SelectSubset<T, AnnonceDeleteArgs>
    ): Prisma__AnnonceClient<AnnonceGetPayload<T>>

    /**
     * Update one Annonce.
     * @param {AnnonceUpdateArgs} args - Arguments to update one Annonce.
     * @example
     * // Update one Annonce
     * const annonce = await prisma.annonce.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AnnonceUpdateArgs>(
      args: SelectSubset<T, AnnonceUpdateArgs>
    ): Prisma__AnnonceClient<AnnonceGetPayload<T>>

    /**
     * Delete zero or more Annonces.
     * @param {AnnonceDeleteManyArgs} args - Arguments to filter Annonces to delete.
     * @example
     * // Delete a few Annonces
     * const { count } = await prisma.annonce.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AnnonceDeleteManyArgs>(
      args?: SelectSubset<T, AnnonceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Annonces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnonceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Annonces
     * const annonce = await prisma.annonce.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AnnonceUpdateManyArgs>(
      args: SelectSubset<T, AnnonceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Annonce.
     * @param {AnnonceUpsertArgs} args - Arguments to update or create a Annonce.
     * @example
     * // Update or create a Annonce
     * const annonce = await prisma.annonce.upsert({
     *   create: {
     *     // ... data to create a Annonce
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Annonce we want to update
     *   }
     * })
    **/
    upsert<T extends AnnonceUpsertArgs>(
      args: SelectSubset<T, AnnonceUpsertArgs>
    ): Prisma__AnnonceClient<AnnonceGetPayload<T>>

    /**
     * Count the number of Annonces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnonceCountArgs} args - Arguments to filter Annonces to count.
     * @example
     * // Count the number of Annonces
     * const count = await prisma.annonce.count({
     *   where: {
     *     // ... the filter for the Annonces we want to count
     *   }
     * })
    **/
    count<T extends AnnonceCountArgs>(
      args?: Subset<T, AnnonceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnonceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Annonce.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnonceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnonceAggregateArgs>(args: Subset<T, AnnonceAggregateArgs>): PrismaPromise<GetAnnonceAggregateType<T>>

    /**
     * Group by Annonce.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnonceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnonceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnonceGroupByArgs['orderBy'] }
        : { orderBy?: AnnonceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnonceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnonceGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Annonce.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AnnonceClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    gardiennage<T extends GardiennageArgs= {}>(args?: Subset<T, GardiennageArgs>): Prisma__GardiennageClient<GardiennageGetPayload<T> | Null>;

    photo<T extends Annonce$photoArgs= {}>(args?: Subset<T, Annonce$photoArgs>): PrismaPromise<Array<PhotoAnnonceGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Annonce base type for findUnique actions
   */
  export type AnnonceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Annonce
     */
    select?: AnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnonceInclude | null
    /**
     * Filter, which Annonce to fetch.
     */
    where: AnnonceWhereUniqueInput
  }

  /**
   * Annonce findUnique
   */
  export interface AnnonceFindUniqueArgs extends AnnonceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Annonce findUniqueOrThrow
   */
  export type AnnonceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Annonce
     */
    select?: AnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnonceInclude | null
    /**
     * Filter, which Annonce to fetch.
     */
    where: AnnonceWhereUniqueInput
  }


  /**
   * Annonce base type for findFirst actions
   */
  export type AnnonceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Annonce
     */
    select?: AnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnonceInclude | null
    /**
     * Filter, which Annonce to fetch.
     */
    where?: AnnonceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annonces to fetch.
     */
    orderBy?: Enumerable<AnnonceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Annonces.
     */
    cursor?: AnnonceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annonces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annonces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Annonces.
     */
    distinct?: Enumerable<AnnonceScalarFieldEnum>
  }

  /**
   * Annonce findFirst
   */
  export interface AnnonceFindFirstArgs extends AnnonceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Annonce findFirstOrThrow
   */
  export type AnnonceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Annonce
     */
    select?: AnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnonceInclude | null
    /**
     * Filter, which Annonce to fetch.
     */
    where?: AnnonceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annonces to fetch.
     */
    orderBy?: Enumerable<AnnonceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Annonces.
     */
    cursor?: AnnonceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annonces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annonces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Annonces.
     */
    distinct?: Enumerable<AnnonceScalarFieldEnum>
  }


  /**
   * Annonce findMany
   */
  export type AnnonceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Annonce
     */
    select?: AnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnonceInclude | null
    /**
     * Filter, which Annonces to fetch.
     */
    where?: AnnonceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annonces to fetch.
     */
    orderBy?: Enumerable<AnnonceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Annonces.
     */
    cursor?: AnnonceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annonces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annonces.
     */
    skip?: number
    distinct?: Enumerable<AnnonceScalarFieldEnum>
  }


  /**
   * Annonce create
   */
  export type AnnonceCreateArgs = {
    /**
     * Select specific fields to fetch from the Annonce
     */
    select?: AnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnonceInclude | null
    /**
     * The data needed to create a Annonce.
     */
    data: XOR<AnnonceCreateInput, AnnonceUncheckedCreateInput>
  }


  /**
   * Annonce update
   */
  export type AnnonceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Annonce
     */
    select?: AnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnonceInclude | null
    /**
     * The data needed to update a Annonce.
     */
    data: XOR<AnnonceUpdateInput, AnnonceUncheckedUpdateInput>
    /**
     * Choose, which Annonce to update.
     */
    where: AnnonceWhereUniqueInput
  }


  /**
   * Annonce updateMany
   */
  export type AnnonceUpdateManyArgs = {
    /**
     * The data used to update Annonces.
     */
    data: XOR<AnnonceUpdateManyMutationInput, AnnonceUncheckedUpdateManyInput>
    /**
     * Filter which Annonces to update
     */
    where?: AnnonceWhereInput
  }


  /**
   * Annonce upsert
   */
  export type AnnonceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Annonce
     */
    select?: AnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnonceInclude | null
    /**
     * The filter to search for the Annonce to update in case it exists.
     */
    where: AnnonceWhereUniqueInput
    /**
     * In case the Annonce found by the `where` argument doesn't exist, create a new Annonce with this data.
     */
    create: XOR<AnnonceCreateInput, AnnonceUncheckedCreateInput>
    /**
     * In case the Annonce was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnonceUpdateInput, AnnonceUncheckedUpdateInput>
  }


  /**
   * Annonce delete
   */
  export type AnnonceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Annonce
     */
    select?: AnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnonceInclude | null
    /**
     * Filter which Annonce to delete.
     */
    where: AnnonceWhereUniqueInput
  }


  /**
   * Annonce deleteMany
   */
  export type AnnonceDeleteManyArgs = {
    /**
     * Filter which Annonces to delete
     */
    where?: AnnonceWhereInput
  }


  /**
   * Annonce.photo
   */
  export type Annonce$photoArgs = {
    /**
     * Select specific fields to fetch from the PhotoAnnonce
     */
    select?: PhotoAnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAnnonceInclude | null
    where?: PhotoAnnonceWhereInput
    orderBy?: Enumerable<PhotoAnnonceOrderByWithRelationInput>
    cursor?: PhotoAnnonceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PhotoAnnonceScalarFieldEnum>
  }


  /**
   * Annonce without action
   */
  export type AnnonceArgs = {
    /**
     * Select specific fields to fetch from the Annonce
     */
    select?: AnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnnonceInclude | null
  }



  /**
   * Model Gardiennage
   */


  export type AggregateGardiennage = {
    _count: GardiennageCountAggregateOutputType | null
    _avg: GardiennageAvgAggregateOutputType | null
    _sum: GardiennageSumAggregateOutputType | null
    _min: GardiennageMinAggregateOutputType | null
    _max: GardiennageMaxAggregateOutputType | null
  }

  export type GardiennageAvgAggregateOutputType = {
    id_gardiennage: number | null
    id_user: number | null
    idAnnonce: number | null
  }

  export type GardiennageSumAggregateOutputType = {
    id_gardiennage: number | null
    id_user: number | null
    idAnnonce: number | null
  }

  export type GardiennageMinAggregateOutputType = {
    id_gardiennage: number | null
    date_debut: Date | null
    date_fin: Date | null
    description: string | null
    id_user: number | null
    idAnnonce: number | null
  }

  export type GardiennageMaxAggregateOutputType = {
    id_gardiennage: number | null
    date_debut: Date | null
    date_fin: Date | null
    description: string | null
    id_user: number | null
    idAnnonce: number | null
  }

  export type GardiennageCountAggregateOutputType = {
    id_gardiennage: number
    date_debut: number
    date_fin: number
    description: number
    id_user: number
    idAnnonce: number
    _all: number
  }


  export type GardiennageAvgAggregateInputType = {
    id_gardiennage?: true
    id_user?: true
    idAnnonce?: true
  }

  export type GardiennageSumAggregateInputType = {
    id_gardiennage?: true
    id_user?: true
    idAnnonce?: true
  }

  export type GardiennageMinAggregateInputType = {
    id_gardiennage?: true
    date_debut?: true
    date_fin?: true
    description?: true
    id_user?: true
    idAnnonce?: true
  }

  export type GardiennageMaxAggregateInputType = {
    id_gardiennage?: true
    date_debut?: true
    date_fin?: true
    description?: true
    id_user?: true
    idAnnonce?: true
  }

  export type GardiennageCountAggregateInputType = {
    id_gardiennage?: true
    date_debut?: true
    date_fin?: true
    description?: true
    id_user?: true
    idAnnonce?: true
    _all?: true
  }

  export type GardiennageAggregateArgs = {
    /**
     * Filter which Gardiennage to aggregate.
     */
    where?: GardiennageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gardiennages to fetch.
     */
    orderBy?: Enumerable<GardiennageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GardiennageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gardiennages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gardiennages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gardiennages
    **/
    _count?: true | GardiennageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GardiennageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GardiennageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GardiennageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GardiennageMaxAggregateInputType
  }

  export type GetGardiennageAggregateType<T extends GardiennageAggregateArgs> = {
        [P in keyof T & keyof AggregateGardiennage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGardiennage[P]>
      : GetScalarType<T[P], AggregateGardiennage[P]>
  }




  export type GardiennageGroupByArgs = {
    where?: GardiennageWhereInput
    orderBy?: Enumerable<GardiennageOrderByWithAggregationInput>
    by: GardiennageScalarFieldEnum[]
    having?: GardiennageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GardiennageCountAggregateInputType | true
    _avg?: GardiennageAvgAggregateInputType
    _sum?: GardiennageSumAggregateInputType
    _min?: GardiennageMinAggregateInputType
    _max?: GardiennageMaxAggregateInputType
  }


  export type GardiennageGroupByOutputType = {
    id_gardiennage: number
    date_debut: Date
    date_fin: Date
    description: string | null
    id_user: number
    idAnnonce: number
    _count: GardiennageCountAggregateOutputType | null
    _avg: GardiennageAvgAggregateOutputType | null
    _sum: GardiennageSumAggregateOutputType | null
    _min: GardiennageMinAggregateOutputType | null
    _max: GardiennageMaxAggregateOutputType | null
  }

  type GetGardiennageGroupByPayload<T extends GardiennageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<GardiennageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GardiennageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GardiennageGroupByOutputType[P]>
            : GetScalarType<T[P], GardiennageGroupByOutputType[P]>
        }
      >
    >


  export type GardiennageSelect = {
    id_gardiennage?: boolean
    date_debut?: boolean
    date_fin?: boolean
    description?: boolean
    id_user?: boolean
    user?: boolean | UserArgs
    idAnnonce?: boolean
    annonce?: boolean | AnnonceArgs
    photo_gardiennage?: boolean | Gardiennage$photo_gardiennageArgs
    _count?: boolean | GardiennageCountOutputTypeArgs
  }


  export type GardiennageInclude = {
    user?: boolean | UserArgs
    annonce?: boolean | AnnonceArgs
    photo_gardiennage?: boolean | Gardiennage$photo_gardiennageArgs
    _count?: boolean | GardiennageCountOutputTypeArgs
  }

  export type GardiennageGetPayload<S extends boolean | null | undefined | GardiennageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Gardiennage :
    S extends undefined ? never :
    S extends { include: any } & (GardiennageArgs | GardiennageFindManyArgs)
    ? Gardiennage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'annonce' ? AnnonceGetPayload<S['include'][P]> :
        P extends 'photo_gardiennage' ? Array < PhotoGardiennageGetPayload<S['include'][P]>>  :
        P extends '_count' ? GardiennageCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (GardiennageArgs | GardiennageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'annonce' ? AnnonceGetPayload<S['select'][P]> :
        P extends 'photo_gardiennage' ? Array < PhotoGardiennageGetPayload<S['select'][P]>>  :
        P extends '_count' ? GardiennageCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Gardiennage ? Gardiennage[P] : never
  } 
      : Gardiennage


  type GardiennageCountArgs = 
    Omit<GardiennageFindManyArgs, 'select' | 'include'> & {
      select?: GardiennageCountAggregateInputType | true
    }

  export interface GardiennageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Gardiennage that matches the filter.
     * @param {GardiennageFindUniqueArgs} args - Arguments to find a Gardiennage
     * @example
     * // Get one Gardiennage
     * const gardiennage = await prisma.gardiennage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GardiennageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GardiennageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Gardiennage'> extends True ? Prisma__GardiennageClient<GardiennageGetPayload<T>> : Prisma__GardiennageClient<GardiennageGetPayload<T> | null, null>

    /**
     * Find one Gardiennage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GardiennageFindUniqueOrThrowArgs} args - Arguments to find a Gardiennage
     * @example
     * // Get one Gardiennage
     * const gardiennage = await prisma.gardiennage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GardiennageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GardiennageFindUniqueOrThrowArgs>
    ): Prisma__GardiennageClient<GardiennageGetPayload<T>>

    /**
     * Find the first Gardiennage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardiennageFindFirstArgs} args - Arguments to find a Gardiennage
     * @example
     * // Get one Gardiennage
     * const gardiennage = await prisma.gardiennage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GardiennageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GardiennageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Gardiennage'> extends True ? Prisma__GardiennageClient<GardiennageGetPayload<T>> : Prisma__GardiennageClient<GardiennageGetPayload<T> | null, null>

    /**
     * Find the first Gardiennage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardiennageFindFirstOrThrowArgs} args - Arguments to find a Gardiennage
     * @example
     * // Get one Gardiennage
     * const gardiennage = await prisma.gardiennage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GardiennageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GardiennageFindFirstOrThrowArgs>
    ): Prisma__GardiennageClient<GardiennageGetPayload<T>>

    /**
     * Find zero or more Gardiennages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardiennageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gardiennages
     * const gardiennages = await prisma.gardiennage.findMany()
     * 
     * // Get first 10 Gardiennages
     * const gardiennages = await prisma.gardiennage.findMany({ take: 10 })
     * 
     * // Only select the `id_gardiennage`
     * const gardiennageWithId_gardiennageOnly = await prisma.gardiennage.findMany({ select: { id_gardiennage: true } })
     * 
    **/
    findMany<T extends GardiennageFindManyArgs>(
      args?: SelectSubset<T, GardiennageFindManyArgs>
    ): PrismaPromise<Array<GardiennageGetPayload<T>>>

    /**
     * Create a Gardiennage.
     * @param {GardiennageCreateArgs} args - Arguments to create a Gardiennage.
     * @example
     * // Create one Gardiennage
     * const Gardiennage = await prisma.gardiennage.create({
     *   data: {
     *     // ... data to create a Gardiennage
     *   }
     * })
     * 
    **/
    create<T extends GardiennageCreateArgs>(
      args: SelectSubset<T, GardiennageCreateArgs>
    ): Prisma__GardiennageClient<GardiennageGetPayload<T>>

    /**
     * Delete a Gardiennage.
     * @param {GardiennageDeleteArgs} args - Arguments to delete one Gardiennage.
     * @example
     * // Delete one Gardiennage
     * const Gardiennage = await prisma.gardiennage.delete({
     *   where: {
     *     // ... filter to delete one Gardiennage
     *   }
     * })
     * 
    **/
    delete<T extends GardiennageDeleteArgs>(
      args: SelectSubset<T, GardiennageDeleteArgs>
    ): Prisma__GardiennageClient<GardiennageGetPayload<T>>

    /**
     * Update one Gardiennage.
     * @param {GardiennageUpdateArgs} args - Arguments to update one Gardiennage.
     * @example
     * // Update one Gardiennage
     * const gardiennage = await prisma.gardiennage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GardiennageUpdateArgs>(
      args: SelectSubset<T, GardiennageUpdateArgs>
    ): Prisma__GardiennageClient<GardiennageGetPayload<T>>

    /**
     * Delete zero or more Gardiennages.
     * @param {GardiennageDeleteManyArgs} args - Arguments to filter Gardiennages to delete.
     * @example
     * // Delete a few Gardiennages
     * const { count } = await prisma.gardiennage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GardiennageDeleteManyArgs>(
      args?: SelectSubset<T, GardiennageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gardiennages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardiennageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gardiennages
     * const gardiennage = await prisma.gardiennage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GardiennageUpdateManyArgs>(
      args: SelectSubset<T, GardiennageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Gardiennage.
     * @param {GardiennageUpsertArgs} args - Arguments to update or create a Gardiennage.
     * @example
     * // Update or create a Gardiennage
     * const gardiennage = await prisma.gardiennage.upsert({
     *   create: {
     *     // ... data to create a Gardiennage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gardiennage we want to update
     *   }
     * })
    **/
    upsert<T extends GardiennageUpsertArgs>(
      args: SelectSubset<T, GardiennageUpsertArgs>
    ): Prisma__GardiennageClient<GardiennageGetPayload<T>>

    /**
     * Count the number of Gardiennages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardiennageCountArgs} args - Arguments to filter Gardiennages to count.
     * @example
     * // Count the number of Gardiennages
     * const count = await prisma.gardiennage.count({
     *   where: {
     *     // ... the filter for the Gardiennages we want to count
     *   }
     * })
    **/
    count<T extends GardiennageCountArgs>(
      args?: Subset<T, GardiennageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GardiennageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gardiennage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardiennageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GardiennageAggregateArgs>(args: Subset<T, GardiennageAggregateArgs>): PrismaPromise<GetGardiennageAggregateType<T>>

    /**
     * Group by Gardiennage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GardiennageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GardiennageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GardiennageGroupByArgs['orderBy'] }
        : { orderBy?: GardiennageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GardiennageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGardiennageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Gardiennage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GardiennageClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    annonce<T extends AnnonceArgs= {}>(args?: Subset<T, AnnonceArgs>): Prisma__AnnonceClient<AnnonceGetPayload<T> | Null>;

    photo_gardiennage<T extends Gardiennage$photo_gardiennageArgs= {}>(args?: Subset<T, Gardiennage$photo_gardiennageArgs>): PrismaPromise<Array<PhotoGardiennageGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Gardiennage base type for findUnique actions
   */
  export type GardiennageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Gardiennage
     */
    select?: GardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GardiennageInclude | null
    /**
     * Filter, which Gardiennage to fetch.
     */
    where: GardiennageWhereUniqueInput
  }

  /**
   * Gardiennage findUnique
   */
  export interface GardiennageFindUniqueArgs extends GardiennageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Gardiennage findUniqueOrThrow
   */
  export type GardiennageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Gardiennage
     */
    select?: GardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GardiennageInclude | null
    /**
     * Filter, which Gardiennage to fetch.
     */
    where: GardiennageWhereUniqueInput
  }


  /**
   * Gardiennage base type for findFirst actions
   */
  export type GardiennageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Gardiennage
     */
    select?: GardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GardiennageInclude | null
    /**
     * Filter, which Gardiennage to fetch.
     */
    where?: GardiennageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gardiennages to fetch.
     */
    orderBy?: Enumerable<GardiennageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gardiennages.
     */
    cursor?: GardiennageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gardiennages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gardiennages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gardiennages.
     */
    distinct?: Enumerable<GardiennageScalarFieldEnum>
  }

  /**
   * Gardiennage findFirst
   */
  export interface GardiennageFindFirstArgs extends GardiennageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Gardiennage findFirstOrThrow
   */
  export type GardiennageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Gardiennage
     */
    select?: GardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GardiennageInclude | null
    /**
     * Filter, which Gardiennage to fetch.
     */
    where?: GardiennageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gardiennages to fetch.
     */
    orderBy?: Enumerable<GardiennageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gardiennages.
     */
    cursor?: GardiennageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gardiennages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gardiennages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gardiennages.
     */
    distinct?: Enumerable<GardiennageScalarFieldEnum>
  }


  /**
   * Gardiennage findMany
   */
  export type GardiennageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Gardiennage
     */
    select?: GardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GardiennageInclude | null
    /**
     * Filter, which Gardiennages to fetch.
     */
    where?: GardiennageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gardiennages to fetch.
     */
    orderBy?: Enumerable<GardiennageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gardiennages.
     */
    cursor?: GardiennageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gardiennages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gardiennages.
     */
    skip?: number
    distinct?: Enumerable<GardiennageScalarFieldEnum>
  }


  /**
   * Gardiennage create
   */
  export type GardiennageCreateArgs = {
    /**
     * Select specific fields to fetch from the Gardiennage
     */
    select?: GardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GardiennageInclude | null
    /**
     * The data needed to create a Gardiennage.
     */
    data: XOR<GardiennageCreateInput, GardiennageUncheckedCreateInput>
  }


  /**
   * Gardiennage update
   */
  export type GardiennageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Gardiennage
     */
    select?: GardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GardiennageInclude | null
    /**
     * The data needed to update a Gardiennage.
     */
    data: XOR<GardiennageUpdateInput, GardiennageUncheckedUpdateInput>
    /**
     * Choose, which Gardiennage to update.
     */
    where: GardiennageWhereUniqueInput
  }


  /**
   * Gardiennage updateMany
   */
  export type GardiennageUpdateManyArgs = {
    /**
     * The data used to update Gardiennages.
     */
    data: XOR<GardiennageUpdateManyMutationInput, GardiennageUncheckedUpdateManyInput>
    /**
     * Filter which Gardiennages to update
     */
    where?: GardiennageWhereInput
  }


  /**
   * Gardiennage upsert
   */
  export type GardiennageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Gardiennage
     */
    select?: GardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GardiennageInclude | null
    /**
     * The filter to search for the Gardiennage to update in case it exists.
     */
    where: GardiennageWhereUniqueInput
    /**
     * In case the Gardiennage found by the `where` argument doesn't exist, create a new Gardiennage with this data.
     */
    create: XOR<GardiennageCreateInput, GardiennageUncheckedCreateInput>
    /**
     * In case the Gardiennage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GardiennageUpdateInput, GardiennageUncheckedUpdateInput>
  }


  /**
   * Gardiennage delete
   */
  export type GardiennageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Gardiennage
     */
    select?: GardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GardiennageInclude | null
    /**
     * Filter which Gardiennage to delete.
     */
    where: GardiennageWhereUniqueInput
  }


  /**
   * Gardiennage deleteMany
   */
  export type GardiennageDeleteManyArgs = {
    /**
     * Filter which Gardiennages to delete
     */
    where?: GardiennageWhereInput
  }


  /**
   * Gardiennage.photo_gardiennage
   */
  export type Gardiennage$photo_gardiennageArgs = {
    /**
     * Select specific fields to fetch from the PhotoGardiennage
     */
    select?: PhotoGardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoGardiennageInclude | null
    where?: PhotoGardiennageWhereInput
    orderBy?: Enumerable<PhotoGardiennageOrderByWithRelationInput>
    cursor?: PhotoGardiennageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PhotoGardiennageScalarFieldEnum>
  }


  /**
   * Gardiennage without action
   */
  export type GardiennageArgs = {
    /**
     * Select specific fields to fetch from the Gardiennage
     */
    select?: GardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GardiennageInclude | null
  }



  /**
   * Model PhotoGardiennage
   */


  export type AggregatePhotoGardiennage = {
    _count: PhotoGardiennageCountAggregateOutputType | null
    _avg: PhotoGardiennageAvgAggregateOutputType | null
    _sum: PhotoGardiennageSumAggregateOutputType | null
    _min: PhotoGardiennageMinAggregateOutputType | null
    _max: PhotoGardiennageMaxAggregateOutputType | null
  }

  export type PhotoGardiennageAvgAggregateOutputType = {
    id_photo: number | null
    idGardiennage: number | null
  }

  export type PhotoGardiennageSumAggregateOutputType = {
    id_photo: number | null
    idGardiennage: number | null
  }

  export type PhotoGardiennageMinAggregateOutputType = {
    id_photo: number | null
    lien: string | null
    date_photo: Date | null
    idGardiennage: number | null
  }

  export type PhotoGardiennageMaxAggregateOutputType = {
    id_photo: number | null
    lien: string | null
    date_photo: Date | null
    idGardiennage: number | null
  }

  export type PhotoGardiennageCountAggregateOutputType = {
    id_photo: number
    lien: number
    date_photo: number
    idGardiennage: number
    _all: number
  }


  export type PhotoGardiennageAvgAggregateInputType = {
    id_photo?: true
    idGardiennage?: true
  }

  export type PhotoGardiennageSumAggregateInputType = {
    id_photo?: true
    idGardiennage?: true
  }

  export type PhotoGardiennageMinAggregateInputType = {
    id_photo?: true
    lien?: true
    date_photo?: true
    idGardiennage?: true
  }

  export type PhotoGardiennageMaxAggregateInputType = {
    id_photo?: true
    lien?: true
    date_photo?: true
    idGardiennage?: true
  }

  export type PhotoGardiennageCountAggregateInputType = {
    id_photo?: true
    lien?: true
    date_photo?: true
    idGardiennage?: true
    _all?: true
  }

  export type PhotoGardiennageAggregateArgs = {
    /**
     * Filter which PhotoGardiennage to aggregate.
     */
    where?: PhotoGardiennageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoGardiennages to fetch.
     */
    orderBy?: Enumerable<PhotoGardiennageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhotoGardiennageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoGardiennages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoGardiennages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhotoGardiennages
    **/
    _count?: true | PhotoGardiennageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhotoGardiennageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhotoGardiennageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhotoGardiennageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhotoGardiennageMaxAggregateInputType
  }

  export type GetPhotoGardiennageAggregateType<T extends PhotoGardiennageAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotoGardiennage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotoGardiennage[P]>
      : GetScalarType<T[P], AggregatePhotoGardiennage[P]>
  }




  export type PhotoGardiennageGroupByArgs = {
    where?: PhotoGardiennageWhereInput
    orderBy?: Enumerable<PhotoGardiennageOrderByWithAggregationInput>
    by: PhotoGardiennageScalarFieldEnum[]
    having?: PhotoGardiennageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhotoGardiennageCountAggregateInputType | true
    _avg?: PhotoGardiennageAvgAggregateInputType
    _sum?: PhotoGardiennageSumAggregateInputType
    _min?: PhotoGardiennageMinAggregateInputType
    _max?: PhotoGardiennageMaxAggregateInputType
  }


  export type PhotoGardiennageGroupByOutputType = {
    id_photo: number
    lien: string
    date_photo: Date
    idGardiennage: number
    _count: PhotoGardiennageCountAggregateOutputType | null
    _avg: PhotoGardiennageAvgAggregateOutputType | null
    _sum: PhotoGardiennageSumAggregateOutputType | null
    _min: PhotoGardiennageMinAggregateOutputType | null
    _max: PhotoGardiennageMaxAggregateOutputType | null
  }

  type GetPhotoGardiennageGroupByPayload<T extends PhotoGardiennageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PhotoGardiennageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhotoGardiennageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhotoGardiennageGroupByOutputType[P]>
            : GetScalarType<T[P], PhotoGardiennageGroupByOutputType[P]>
        }
      >
    >


  export type PhotoGardiennageSelect = {
    id_photo?: boolean
    lien?: boolean
    date_photo?: boolean
    idGardiennage?: boolean
    gardiennage?: boolean | GardiennageArgs
  }


  export type PhotoGardiennageInclude = {
    gardiennage?: boolean | GardiennageArgs
  }

  export type PhotoGardiennageGetPayload<S extends boolean | null | undefined | PhotoGardiennageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PhotoGardiennage :
    S extends undefined ? never :
    S extends { include: any } & (PhotoGardiennageArgs | PhotoGardiennageFindManyArgs)
    ? PhotoGardiennage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'gardiennage' ? GardiennageGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PhotoGardiennageArgs | PhotoGardiennageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'gardiennage' ? GardiennageGetPayload<S['select'][P]> :  P extends keyof PhotoGardiennage ? PhotoGardiennage[P] : never
  } 
      : PhotoGardiennage


  type PhotoGardiennageCountArgs = 
    Omit<PhotoGardiennageFindManyArgs, 'select' | 'include'> & {
      select?: PhotoGardiennageCountAggregateInputType | true
    }

  export interface PhotoGardiennageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PhotoGardiennage that matches the filter.
     * @param {PhotoGardiennageFindUniqueArgs} args - Arguments to find a PhotoGardiennage
     * @example
     * // Get one PhotoGardiennage
     * const photoGardiennage = await prisma.photoGardiennage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PhotoGardiennageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PhotoGardiennageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PhotoGardiennage'> extends True ? Prisma__PhotoGardiennageClient<PhotoGardiennageGetPayload<T>> : Prisma__PhotoGardiennageClient<PhotoGardiennageGetPayload<T> | null, null>

    /**
     * Find one PhotoGardiennage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PhotoGardiennageFindUniqueOrThrowArgs} args - Arguments to find a PhotoGardiennage
     * @example
     * // Get one PhotoGardiennage
     * const photoGardiennage = await prisma.photoGardiennage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PhotoGardiennageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PhotoGardiennageFindUniqueOrThrowArgs>
    ): Prisma__PhotoGardiennageClient<PhotoGardiennageGetPayload<T>>

    /**
     * Find the first PhotoGardiennage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoGardiennageFindFirstArgs} args - Arguments to find a PhotoGardiennage
     * @example
     * // Get one PhotoGardiennage
     * const photoGardiennage = await prisma.photoGardiennage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PhotoGardiennageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PhotoGardiennageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PhotoGardiennage'> extends True ? Prisma__PhotoGardiennageClient<PhotoGardiennageGetPayload<T>> : Prisma__PhotoGardiennageClient<PhotoGardiennageGetPayload<T> | null, null>

    /**
     * Find the first PhotoGardiennage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoGardiennageFindFirstOrThrowArgs} args - Arguments to find a PhotoGardiennage
     * @example
     * // Get one PhotoGardiennage
     * const photoGardiennage = await prisma.photoGardiennage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PhotoGardiennageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PhotoGardiennageFindFirstOrThrowArgs>
    ): Prisma__PhotoGardiennageClient<PhotoGardiennageGetPayload<T>>

    /**
     * Find zero or more PhotoGardiennages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoGardiennageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhotoGardiennages
     * const photoGardiennages = await prisma.photoGardiennage.findMany()
     * 
     * // Get first 10 PhotoGardiennages
     * const photoGardiennages = await prisma.photoGardiennage.findMany({ take: 10 })
     * 
     * // Only select the `id_photo`
     * const photoGardiennageWithId_photoOnly = await prisma.photoGardiennage.findMany({ select: { id_photo: true } })
     * 
    **/
    findMany<T extends PhotoGardiennageFindManyArgs>(
      args?: SelectSubset<T, PhotoGardiennageFindManyArgs>
    ): PrismaPromise<Array<PhotoGardiennageGetPayload<T>>>

    /**
     * Create a PhotoGardiennage.
     * @param {PhotoGardiennageCreateArgs} args - Arguments to create a PhotoGardiennage.
     * @example
     * // Create one PhotoGardiennage
     * const PhotoGardiennage = await prisma.photoGardiennage.create({
     *   data: {
     *     // ... data to create a PhotoGardiennage
     *   }
     * })
     * 
    **/
    create<T extends PhotoGardiennageCreateArgs>(
      args: SelectSubset<T, PhotoGardiennageCreateArgs>
    ): Prisma__PhotoGardiennageClient<PhotoGardiennageGetPayload<T>>

    /**
     * Delete a PhotoGardiennage.
     * @param {PhotoGardiennageDeleteArgs} args - Arguments to delete one PhotoGardiennage.
     * @example
     * // Delete one PhotoGardiennage
     * const PhotoGardiennage = await prisma.photoGardiennage.delete({
     *   where: {
     *     // ... filter to delete one PhotoGardiennage
     *   }
     * })
     * 
    **/
    delete<T extends PhotoGardiennageDeleteArgs>(
      args: SelectSubset<T, PhotoGardiennageDeleteArgs>
    ): Prisma__PhotoGardiennageClient<PhotoGardiennageGetPayload<T>>

    /**
     * Update one PhotoGardiennage.
     * @param {PhotoGardiennageUpdateArgs} args - Arguments to update one PhotoGardiennage.
     * @example
     * // Update one PhotoGardiennage
     * const photoGardiennage = await prisma.photoGardiennage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PhotoGardiennageUpdateArgs>(
      args: SelectSubset<T, PhotoGardiennageUpdateArgs>
    ): Prisma__PhotoGardiennageClient<PhotoGardiennageGetPayload<T>>

    /**
     * Delete zero or more PhotoGardiennages.
     * @param {PhotoGardiennageDeleteManyArgs} args - Arguments to filter PhotoGardiennages to delete.
     * @example
     * // Delete a few PhotoGardiennages
     * const { count } = await prisma.photoGardiennage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PhotoGardiennageDeleteManyArgs>(
      args?: SelectSubset<T, PhotoGardiennageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhotoGardiennages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoGardiennageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhotoGardiennages
     * const photoGardiennage = await prisma.photoGardiennage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PhotoGardiennageUpdateManyArgs>(
      args: SelectSubset<T, PhotoGardiennageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PhotoGardiennage.
     * @param {PhotoGardiennageUpsertArgs} args - Arguments to update or create a PhotoGardiennage.
     * @example
     * // Update or create a PhotoGardiennage
     * const photoGardiennage = await prisma.photoGardiennage.upsert({
     *   create: {
     *     // ... data to create a PhotoGardiennage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhotoGardiennage we want to update
     *   }
     * })
    **/
    upsert<T extends PhotoGardiennageUpsertArgs>(
      args: SelectSubset<T, PhotoGardiennageUpsertArgs>
    ): Prisma__PhotoGardiennageClient<PhotoGardiennageGetPayload<T>>

    /**
     * Count the number of PhotoGardiennages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoGardiennageCountArgs} args - Arguments to filter PhotoGardiennages to count.
     * @example
     * // Count the number of PhotoGardiennages
     * const count = await prisma.photoGardiennage.count({
     *   where: {
     *     // ... the filter for the PhotoGardiennages we want to count
     *   }
     * })
    **/
    count<T extends PhotoGardiennageCountArgs>(
      args?: Subset<T, PhotoGardiennageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhotoGardiennageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhotoGardiennage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoGardiennageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhotoGardiennageAggregateArgs>(args: Subset<T, PhotoGardiennageAggregateArgs>): PrismaPromise<GetPhotoGardiennageAggregateType<T>>

    /**
     * Group by PhotoGardiennage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoGardiennageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhotoGardiennageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhotoGardiennageGroupByArgs['orderBy'] }
        : { orderBy?: PhotoGardiennageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhotoGardiennageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotoGardiennageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PhotoGardiennage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PhotoGardiennageClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    gardiennage<T extends GardiennageArgs= {}>(args?: Subset<T, GardiennageArgs>): Prisma__GardiennageClient<GardiennageGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PhotoGardiennage base type for findUnique actions
   */
  export type PhotoGardiennageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PhotoGardiennage
     */
    select?: PhotoGardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoGardiennageInclude | null
    /**
     * Filter, which PhotoGardiennage to fetch.
     */
    where: PhotoGardiennageWhereUniqueInput
  }

  /**
   * PhotoGardiennage findUnique
   */
  export interface PhotoGardiennageFindUniqueArgs extends PhotoGardiennageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PhotoGardiennage findUniqueOrThrow
   */
  export type PhotoGardiennageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PhotoGardiennage
     */
    select?: PhotoGardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoGardiennageInclude | null
    /**
     * Filter, which PhotoGardiennage to fetch.
     */
    where: PhotoGardiennageWhereUniqueInput
  }


  /**
   * PhotoGardiennage base type for findFirst actions
   */
  export type PhotoGardiennageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PhotoGardiennage
     */
    select?: PhotoGardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoGardiennageInclude | null
    /**
     * Filter, which PhotoGardiennage to fetch.
     */
    where?: PhotoGardiennageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoGardiennages to fetch.
     */
    orderBy?: Enumerable<PhotoGardiennageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhotoGardiennages.
     */
    cursor?: PhotoGardiennageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoGardiennages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoGardiennages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhotoGardiennages.
     */
    distinct?: Enumerable<PhotoGardiennageScalarFieldEnum>
  }

  /**
   * PhotoGardiennage findFirst
   */
  export interface PhotoGardiennageFindFirstArgs extends PhotoGardiennageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PhotoGardiennage findFirstOrThrow
   */
  export type PhotoGardiennageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PhotoGardiennage
     */
    select?: PhotoGardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoGardiennageInclude | null
    /**
     * Filter, which PhotoGardiennage to fetch.
     */
    where?: PhotoGardiennageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoGardiennages to fetch.
     */
    orderBy?: Enumerable<PhotoGardiennageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhotoGardiennages.
     */
    cursor?: PhotoGardiennageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoGardiennages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoGardiennages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhotoGardiennages.
     */
    distinct?: Enumerable<PhotoGardiennageScalarFieldEnum>
  }


  /**
   * PhotoGardiennage findMany
   */
  export type PhotoGardiennageFindManyArgs = {
    /**
     * Select specific fields to fetch from the PhotoGardiennage
     */
    select?: PhotoGardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoGardiennageInclude | null
    /**
     * Filter, which PhotoGardiennages to fetch.
     */
    where?: PhotoGardiennageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoGardiennages to fetch.
     */
    orderBy?: Enumerable<PhotoGardiennageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhotoGardiennages.
     */
    cursor?: PhotoGardiennageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoGardiennages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoGardiennages.
     */
    skip?: number
    distinct?: Enumerable<PhotoGardiennageScalarFieldEnum>
  }


  /**
   * PhotoGardiennage create
   */
  export type PhotoGardiennageCreateArgs = {
    /**
     * Select specific fields to fetch from the PhotoGardiennage
     */
    select?: PhotoGardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoGardiennageInclude | null
    /**
     * The data needed to create a PhotoGardiennage.
     */
    data: XOR<PhotoGardiennageCreateInput, PhotoGardiennageUncheckedCreateInput>
  }


  /**
   * PhotoGardiennage update
   */
  export type PhotoGardiennageUpdateArgs = {
    /**
     * Select specific fields to fetch from the PhotoGardiennage
     */
    select?: PhotoGardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoGardiennageInclude | null
    /**
     * The data needed to update a PhotoGardiennage.
     */
    data: XOR<PhotoGardiennageUpdateInput, PhotoGardiennageUncheckedUpdateInput>
    /**
     * Choose, which PhotoGardiennage to update.
     */
    where: PhotoGardiennageWhereUniqueInput
  }


  /**
   * PhotoGardiennage updateMany
   */
  export type PhotoGardiennageUpdateManyArgs = {
    /**
     * The data used to update PhotoGardiennages.
     */
    data: XOR<PhotoGardiennageUpdateManyMutationInput, PhotoGardiennageUncheckedUpdateManyInput>
    /**
     * Filter which PhotoGardiennages to update
     */
    where?: PhotoGardiennageWhereInput
  }


  /**
   * PhotoGardiennage upsert
   */
  export type PhotoGardiennageUpsertArgs = {
    /**
     * Select specific fields to fetch from the PhotoGardiennage
     */
    select?: PhotoGardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoGardiennageInclude | null
    /**
     * The filter to search for the PhotoGardiennage to update in case it exists.
     */
    where: PhotoGardiennageWhereUniqueInput
    /**
     * In case the PhotoGardiennage found by the `where` argument doesn't exist, create a new PhotoGardiennage with this data.
     */
    create: XOR<PhotoGardiennageCreateInput, PhotoGardiennageUncheckedCreateInput>
    /**
     * In case the PhotoGardiennage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhotoGardiennageUpdateInput, PhotoGardiennageUncheckedUpdateInput>
  }


  /**
   * PhotoGardiennage delete
   */
  export type PhotoGardiennageDeleteArgs = {
    /**
     * Select specific fields to fetch from the PhotoGardiennage
     */
    select?: PhotoGardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoGardiennageInclude | null
    /**
     * Filter which PhotoGardiennage to delete.
     */
    where: PhotoGardiennageWhereUniqueInput
  }


  /**
   * PhotoGardiennage deleteMany
   */
  export type PhotoGardiennageDeleteManyArgs = {
    /**
     * Filter which PhotoGardiennages to delete
     */
    where?: PhotoGardiennageWhereInput
  }


  /**
   * PhotoGardiennage without action
   */
  export type PhotoGardiennageArgs = {
    /**
     * Select specific fields to fetch from the PhotoGardiennage
     */
    select?: PhotoGardiennageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoGardiennageInclude | null
  }



  /**
   * Model PhotoAnnonce
   */


  export type AggregatePhotoAnnonce = {
    _count: PhotoAnnonceCountAggregateOutputType | null
    _avg: PhotoAnnonceAvgAggregateOutputType | null
    _sum: PhotoAnnonceSumAggregateOutputType | null
    _min: PhotoAnnonceMinAggregateOutputType | null
    _max: PhotoAnnonceMaxAggregateOutputType | null
  }

  export type PhotoAnnonceAvgAggregateOutputType = {
    id_photo: number | null
    idAnnonce: number | null
  }

  export type PhotoAnnonceSumAggregateOutputType = {
    id_photo: number | null
    idAnnonce: number | null
  }

  export type PhotoAnnonceMinAggregateOutputType = {
    id_photo: number | null
    lien: string | null
    date_photo: Date | null
    idAnnonce: number | null
  }

  export type PhotoAnnonceMaxAggregateOutputType = {
    id_photo: number | null
    lien: string | null
    date_photo: Date | null
    idAnnonce: number | null
  }

  export type PhotoAnnonceCountAggregateOutputType = {
    id_photo: number
    lien: number
    date_photo: number
    idAnnonce: number
    _all: number
  }


  export type PhotoAnnonceAvgAggregateInputType = {
    id_photo?: true
    idAnnonce?: true
  }

  export type PhotoAnnonceSumAggregateInputType = {
    id_photo?: true
    idAnnonce?: true
  }

  export type PhotoAnnonceMinAggregateInputType = {
    id_photo?: true
    lien?: true
    date_photo?: true
    idAnnonce?: true
  }

  export type PhotoAnnonceMaxAggregateInputType = {
    id_photo?: true
    lien?: true
    date_photo?: true
    idAnnonce?: true
  }

  export type PhotoAnnonceCountAggregateInputType = {
    id_photo?: true
    lien?: true
    date_photo?: true
    idAnnonce?: true
    _all?: true
  }

  export type PhotoAnnonceAggregateArgs = {
    /**
     * Filter which PhotoAnnonce to aggregate.
     */
    where?: PhotoAnnonceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoAnnonces to fetch.
     */
    orderBy?: Enumerable<PhotoAnnonceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhotoAnnonceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoAnnonces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoAnnonces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhotoAnnonces
    **/
    _count?: true | PhotoAnnonceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhotoAnnonceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhotoAnnonceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhotoAnnonceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhotoAnnonceMaxAggregateInputType
  }

  export type GetPhotoAnnonceAggregateType<T extends PhotoAnnonceAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotoAnnonce]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotoAnnonce[P]>
      : GetScalarType<T[P], AggregatePhotoAnnonce[P]>
  }




  export type PhotoAnnonceGroupByArgs = {
    where?: PhotoAnnonceWhereInput
    orderBy?: Enumerable<PhotoAnnonceOrderByWithAggregationInput>
    by: PhotoAnnonceScalarFieldEnum[]
    having?: PhotoAnnonceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhotoAnnonceCountAggregateInputType | true
    _avg?: PhotoAnnonceAvgAggregateInputType
    _sum?: PhotoAnnonceSumAggregateInputType
    _min?: PhotoAnnonceMinAggregateInputType
    _max?: PhotoAnnonceMaxAggregateInputType
  }


  export type PhotoAnnonceGroupByOutputType = {
    id_photo: number
    lien: string
    date_photo: Date
    idAnnonce: number
    _count: PhotoAnnonceCountAggregateOutputType | null
    _avg: PhotoAnnonceAvgAggregateOutputType | null
    _sum: PhotoAnnonceSumAggregateOutputType | null
    _min: PhotoAnnonceMinAggregateOutputType | null
    _max: PhotoAnnonceMaxAggregateOutputType | null
  }

  type GetPhotoAnnonceGroupByPayload<T extends PhotoAnnonceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PhotoAnnonceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhotoAnnonceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhotoAnnonceGroupByOutputType[P]>
            : GetScalarType<T[P], PhotoAnnonceGroupByOutputType[P]>
        }
      >
    >


  export type PhotoAnnonceSelect = {
    id_photo?: boolean
    lien?: boolean
    date_photo?: boolean
    idAnnonce?: boolean
    annonce?: boolean | AnnonceArgs
  }


  export type PhotoAnnonceInclude = {
    annonce?: boolean | AnnonceArgs
  }

  export type PhotoAnnonceGetPayload<S extends boolean | null | undefined | PhotoAnnonceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PhotoAnnonce :
    S extends undefined ? never :
    S extends { include: any } & (PhotoAnnonceArgs | PhotoAnnonceFindManyArgs)
    ? PhotoAnnonce  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'annonce' ? AnnonceGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PhotoAnnonceArgs | PhotoAnnonceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'annonce' ? AnnonceGetPayload<S['select'][P]> :  P extends keyof PhotoAnnonce ? PhotoAnnonce[P] : never
  } 
      : PhotoAnnonce


  type PhotoAnnonceCountArgs = 
    Omit<PhotoAnnonceFindManyArgs, 'select' | 'include'> & {
      select?: PhotoAnnonceCountAggregateInputType | true
    }

  export interface PhotoAnnonceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PhotoAnnonce that matches the filter.
     * @param {PhotoAnnonceFindUniqueArgs} args - Arguments to find a PhotoAnnonce
     * @example
     * // Get one PhotoAnnonce
     * const photoAnnonce = await prisma.photoAnnonce.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PhotoAnnonceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PhotoAnnonceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PhotoAnnonce'> extends True ? Prisma__PhotoAnnonceClient<PhotoAnnonceGetPayload<T>> : Prisma__PhotoAnnonceClient<PhotoAnnonceGetPayload<T> | null, null>

    /**
     * Find one PhotoAnnonce that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PhotoAnnonceFindUniqueOrThrowArgs} args - Arguments to find a PhotoAnnonce
     * @example
     * // Get one PhotoAnnonce
     * const photoAnnonce = await prisma.photoAnnonce.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PhotoAnnonceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PhotoAnnonceFindUniqueOrThrowArgs>
    ): Prisma__PhotoAnnonceClient<PhotoAnnonceGetPayload<T>>

    /**
     * Find the first PhotoAnnonce that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAnnonceFindFirstArgs} args - Arguments to find a PhotoAnnonce
     * @example
     * // Get one PhotoAnnonce
     * const photoAnnonce = await prisma.photoAnnonce.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PhotoAnnonceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PhotoAnnonceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PhotoAnnonce'> extends True ? Prisma__PhotoAnnonceClient<PhotoAnnonceGetPayload<T>> : Prisma__PhotoAnnonceClient<PhotoAnnonceGetPayload<T> | null, null>

    /**
     * Find the first PhotoAnnonce that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAnnonceFindFirstOrThrowArgs} args - Arguments to find a PhotoAnnonce
     * @example
     * // Get one PhotoAnnonce
     * const photoAnnonce = await prisma.photoAnnonce.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PhotoAnnonceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PhotoAnnonceFindFirstOrThrowArgs>
    ): Prisma__PhotoAnnonceClient<PhotoAnnonceGetPayload<T>>

    /**
     * Find zero or more PhotoAnnonces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAnnonceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhotoAnnonces
     * const photoAnnonces = await prisma.photoAnnonce.findMany()
     * 
     * // Get first 10 PhotoAnnonces
     * const photoAnnonces = await prisma.photoAnnonce.findMany({ take: 10 })
     * 
     * // Only select the `id_photo`
     * const photoAnnonceWithId_photoOnly = await prisma.photoAnnonce.findMany({ select: { id_photo: true } })
     * 
    **/
    findMany<T extends PhotoAnnonceFindManyArgs>(
      args?: SelectSubset<T, PhotoAnnonceFindManyArgs>
    ): PrismaPromise<Array<PhotoAnnonceGetPayload<T>>>

    /**
     * Create a PhotoAnnonce.
     * @param {PhotoAnnonceCreateArgs} args - Arguments to create a PhotoAnnonce.
     * @example
     * // Create one PhotoAnnonce
     * const PhotoAnnonce = await prisma.photoAnnonce.create({
     *   data: {
     *     // ... data to create a PhotoAnnonce
     *   }
     * })
     * 
    **/
    create<T extends PhotoAnnonceCreateArgs>(
      args: SelectSubset<T, PhotoAnnonceCreateArgs>
    ): Prisma__PhotoAnnonceClient<PhotoAnnonceGetPayload<T>>

    /**
     * Delete a PhotoAnnonce.
     * @param {PhotoAnnonceDeleteArgs} args - Arguments to delete one PhotoAnnonce.
     * @example
     * // Delete one PhotoAnnonce
     * const PhotoAnnonce = await prisma.photoAnnonce.delete({
     *   where: {
     *     // ... filter to delete one PhotoAnnonce
     *   }
     * })
     * 
    **/
    delete<T extends PhotoAnnonceDeleteArgs>(
      args: SelectSubset<T, PhotoAnnonceDeleteArgs>
    ): Prisma__PhotoAnnonceClient<PhotoAnnonceGetPayload<T>>

    /**
     * Update one PhotoAnnonce.
     * @param {PhotoAnnonceUpdateArgs} args - Arguments to update one PhotoAnnonce.
     * @example
     * // Update one PhotoAnnonce
     * const photoAnnonce = await prisma.photoAnnonce.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PhotoAnnonceUpdateArgs>(
      args: SelectSubset<T, PhotoAnnonceUpdateArgs>
    ): Prisma__PhotoAnnonceClient<PhotoAnnonceGetPayload<T>>

    /**
     * Delete zero or more PhotoAnnonces.
     * @param {PhotoAnnonceDeleteManyArgs} args - Arguments to filter PhotoAnnonces to delete.
     * @example
     * // Delete a few PhotoAnnonces
     * const { count } = await prisma.photoAnnonce.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PhotoAnnonceDeleteManyArgs>(
      args?: SelectSubset<T, PhotoAnnonceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhotoAnnonces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAnnonceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhotoAnnonces
     * const photoAnnonce = await prisma.photoAnnonce.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PhotoAnnonceUpdateManyArgs>(
      args: SelectSubset<T, PhotoAnnonceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PhotoAnnonce.
     * @param {PhotoAnnonceUpsertArgs} args - Arguments to update or create a PhotoAnnonce.
     * @example
     * // Update or create a PhotoAnnonce
     * const photoAnnonce = await prisma.photoAnnonce.upsert({
     *   create: {
     *     // ... data to create a PhotoAnnonce
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhotoAnnonce we want to update
     *   }
     * })
    **/
    upsert<T extends PhotoAnnonceUpsertArgs>(
      args: SelectSubset<T, PhotoAnnonceUpsertArgs>
    ): Prisma__PhotoAnnonceClient<PhotoAnnonceGetPayload<T>>

    /**
     * Count the number of PhotoAnnonces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAnnonceCountArgs} args - Arguments to filter PhotoAnnonces to count.
     * @example
     * // Count the number of PhotoAnnonces
     * const count = await prisma.photoAnnonce.count({
     *   where: {
     *     // ... the filter for the PhotoAnnonces we want to count
     *   }
     * })
    **/
    count<T extends PhotoAnnonceCountArgs>(
      args?: Subset<T, PhotoAnnonceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhotoAnnonceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhotoAnnonce.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAnnonceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhotoAnnonceAggregateArgs>(args: Subset<T, PhotoAnnonceAggregateArgs>): PrismaPromise<GetPhotoAnnonceAggregateType<T>>

    /**
     * Group by PhotoAnnonce.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAnnonceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhotoAnnonceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhotoAnnonceGroupByArgs['orderBy'] }
        : { orderBy?: PhotoAnnonceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhotoAnnonceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotoAnnonceGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PhotoAnnonce.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PhotoAnnonceClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    annonce<T extends AnnonceArgs= {}>(args?: Subset<T, AnnonceArgs>): Prisma__AnnonceClient<AnnonceGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PhotoAnnonce base type for findUnique actions
   */
  export type PhotoAnnonceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PhotoAnnonce
     */
    select?: PhotoAnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAnnonceInclude | null
    /**
     * Filter, which PhotoAnnonce to fetch.
     */
    where: PhotoAnnonceWhereUniqueInput
  }

  /**
   * PhotoAnnonce findUnique
   */
  export interface PhotoAnnonceFindUniqueArgs extends PhotoAnnonceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PhotoAnnonce findUniqueOrThrow
   */
  export type PhotoAnnonceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PhotoAnnonce
     */
    select?: PhotoAnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAnnonceInclude | null
    /**
     * Filter, which PhotoAnnonce to fetch.
     */
    where: PhotoAnnonceWhereUniqueInput
  }


  /**
   * PhotoAnnonce base type for findFirst actions
   */
  export type PhotoAnnonceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PhotoAnnonce
     */
    select?: PhotoAnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAnnonceInclude | null
    /**
     * Filter, which PhotoAnnonce to fetch.
     */
    where?: PhotoAnnonceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoAnnonces to fetch.
     */
    orderBy?: Enumerable<PhotoAnnonceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhotoAnnonces.
     */
    cursor?: PhotoAnnonceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoAnnonces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoAnnonces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhotoAnnonces.
     */
    distinct?: Enumerable<PhotoAnnonceScalarFieldEnum>
  }

  /**
   * PhotoAnnonce findFirst
   */
  export interface PhotoAnnonceFindFirstArgs extends PhotoAnnonceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PhotoAnnonce findFirstOrThrow
   */
  export type PhotoAnnonceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PhotoAnnonce
     */
    select?: PhotoAnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAnnonceInclude | null
    /**
     * Filter, which PhotoAnnonce to fetch.
     */
    where?: PhotoAnnonceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoAnnonces to fetch.
     */
    orderBy?: Enumerable<PhotoAnnonceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhotoAnnonces.
     */
    cursor?: PhotoAnnonceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoAnnonces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoAnnonces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhotoAnnonces.
     */
    distinct?: Enumerable<PhotoAnnonceScalarFieldEnum>
  }


  /**
   * PhotoAnnonce findMany
   */
  export type PhotoAnnonceFindManyArgs = {
    /**
     * Select specific fields to fetch from the PhotoAnnonce
     */
    select?: PhotoAnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAnnonceInclude | null
    /**
     * Filter, which PhotoAnnonces to fetch.
     */
    where?: PhotoAnnonceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoAnnonces to fetch.
     */
    orderBy?: Enumerable<PhotoAnnonceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhotoAnnonces.
     */
    cursor?: PhotoAnnonceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoAnnonces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoAnnonces.
     */
    skip?: number
    distinct?: Enumerable<PhotoAnnonceScalarFieldEnum>
  }


  /**
   * PhotoAnnonce create
   */
  export type PhotoAnnonceCreateArgs = {
    /**
     * Select specific fields to fetch from the PhotoAnnonce
     */
    select?: PhotoAnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAnnonceInclude | null
    /**
     * The data needed to create a PhotoAnnonce.
     */
    data: XOR<PhotoAnnonceCreateInput, PhotoAnnonceUncheckedCreateInput>
  }


  /**
   * PhotoAnnonce update
   */
  export type PhotoAnnonceUpdateArgs = {
    /**
     * Select specific fields to fetch from the PhotoAnnonce
     */
    select?: PhotoAnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAnnonceInclude | null
    /**
     * The data needed to update a PhotoAnnonce.
     */
    data: XOR<PhotoAnnonceUpdateInput, PhotoAnnonceUncheckedUpdateInput>
    /**
     * Choose, which PhotoAnnonce to update.
     */
    where: PhotoAnnonceWhereUniqueInput
  }


  /**
   * PhotoAnnonce updateMany
   */
  export type PhotoAnnonceUpdateManyArgs = {
    /**
     * The data used to update PhotoAnnonces.
     */
    data: XOR<PhotoAnnonceUpdateManyMutationInput, PhotoAnnonceUncheckedUpdateManyInput>
    /**
     * Filter which PhotoAnnonces to update
     */
    where?: PhotoAnnonceWhereInput
  }


  /**
   * PhotoAnnonce upsert
   */
  export type PhotoAnnonceUpsertArgs = {
    /**
     * Select specific fields to fetch from the PhotoAnnonce
     */
    select?: PhotoAnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAnnonceInclude | null
    /**
     * The filter to search for the PhotoAnnonce to update in case it exists.
     */
    where: PhotoAnnonceWhereUniqueInput
    /**
     * In case the PhotoAnnonce found by the `where` argument doesn't exist, create a new PhotoAnnonce with this data.
     */
    create: XOR<PhotoAnnonceCreateInput, PhotoAnnonceUncheckedCreateInput>
    /**
     * In case the PhotoAnnonce was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhotoAnnonceUpdateInput, PhotoAnnonceUncheckedUpdateInput>
  }


  /**
   * PhotoAnnonce delete
   */
  export type PhotoAnnonceDeleteArgs = {
    /**
     * Select specific fields to fetch from the PhotoAnnonce
     */
    select?: PhotoAnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAnnonceInclude | null
    /**
     * Filter which PhotoAnnonce to delete.
     */
    where: PhotoAnnonceWhereUniqueInput
  }


  /**
   * PhotoAnnonce deleteMany
   */
  export type PhotoAnnonceDeleteManyArgs = {
    /**
     * Filter which PhotoAnnonces to delete
     */
    where?: PhotoAnnonceWhereInput
  }


  /**
   * PhotoAnnonce without action
   */
  export type PhotoAnnonceArgs = {
    /**
     * Select specific fields to fetch from the PhotoAnnonce
     */
    select?: PhotoAnnonceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoAnnonceInclude | null
  }



  /**
   * Model Conseil
   */


  export type AggregateConseil = {
    _count: ConseilCountAggregateOutputType | null
    _avg: ConseilAvgAggregateOutputType | null
    _sum: ConseilSumAggregateOutputType | null
    _min: ConseilMinAggregateOutputType | null
    _max: ConseilMaxAggregateOutputType | null
  }

  export type ConseilAvgAggregateOutputType = {
    id_consiel: number | null
    idUser: number | null
  }

  export type ConseilSumAggregateOutputType = {
    id_consiel: number | null
    idUser: number | null
  }

  export type ConseilMinAggregateOutputType = {
    id_consiel: number | null
    date_conseil: Date | null
    message: string | null
    idUser: number | null
  }

  export type ConseilMaxAggregateOutputType = {
    id_consiel: number | null
    date_conseil: Date | null
    message: string | null
    idUser: number | null
  }

  export type ConseilCountAggregateOutputType = {
    id_consiel: number
    date_conseil: number
    message: number
    idUser: number
    _all: number
  }


  export type ConseilAvgAggregateInputType = {
    id_consiel?: true
    idUser?: true
  }

  export type ConseilSumAggregateInputType = {
    id_consiel?: true
    idUser?: true
  }

  export type ConseilMinAggregateInputType = {
    id_consiel?: true
    date_conseil?: true
    message?: true
    idUser?: true
  }

  export type ConseilMaxAggregateInputType = {
    id_consiel?: true
    date_conseil?: true
    message?: true
    idUser?: true
  }

  export type ConseilCountAggregateInputType = {
    id_consiel?: true
    date_conseil?: true
    message?: true
    idUser?: true
    _all?: true
  }

  export type ConseilAggregateArgs = {
    /**
     * Filter which Conseil to aggregate.
     */
    where?: ConseilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conseils to fetch.
     */
    orderBy?: Enumerable<ConseilOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConseilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conseils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conseils.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conseils
    **/
    _count?: true | ConseilCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConseilAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConseilSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConseilMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConseilMaxAggregateInputType
  }

  export type GetConseilAggregateType<T extends ConseilAggregateArgs> = {
        [P in keyof T & keyof AggregateConseil]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConseil[P]>
      : GetScalarType<T[P], AggregateConseil[P]>
  }




  export type ConseilGroupByArgs = {
    where?: ConseilWhereInput
    orderBy?: Enumerable<ConseilOrderByWithAggregationInput>
    by: ConseilScalarFieldEnum[]
    having?: ConseilScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConseilCountAggregateInputType | true
    _avg?: ConseilAvgAggregateInputType
    _sum?: ConseilSumAggregateInputType
    _min?: ConseilMinAggregateInputType
    _max?: ConseilMaxAggregateInputType
  }


  export type ConseilGroupByOutputType = {
    id_consiel: number
    date_conseil: Date
    message: string
    idUser: number
    _count: ConseilCountAggregateOutputType | null
    _avg: ConseilAvgAggregateOutputType | null
    _sum: ConseilSumAggregateOutputType | null
    _min: ConseilMinAggregateOutputType | null
    _max: ConseilMaxAggregateOutputType | null
  }

  type GetConseilGroupByPayload<T extends ConseilGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ConseilGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConseilGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConseilGroupByOutputType[P]>
            : GetScalarType<T[P], ConseilGroupByOutputType[P]>
        }
      >
    >


  export type ConseilSelect = {
    id_consiel?: boolean
    date_conseil?: boolean
    message?: boolean
    idUser?: boolean
    user?: boolean | UserArgs
  }


  export type ConseilInclude = {
    user?: boolean | UserArgs
  }

  export type ConseilGetPayload<S extends boolean | null | undefined | ConseilArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Conseil :
    S extends undefined ? never :
    S extends { include: any } & (ConseilArgs | ConseilFindManyArgs)
    ? Conseil  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ConseilArgs | ConseilFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Conseil ? Conseil[P] : never
  } 
      : Conseil


  type ConseilCountArgs = 
    Omit<ConseilFindManyArgs, 'select' | 'include'> & {
      select?: ConseilCountAggregateInputType | true
    }

  export interface ConseilDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Conseil that matches the filter.
     * @param {ConseilFindUniqueArgs} args - Arguments to find a Conseil
     * @example
     * // Get one Conseil
     * const conseil = await prisma.conseil.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConseilFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ConseilFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Conseil'> extends True ? Prisma__ConseilClient<ConseilGetPayload<T>> : Prisma__ConseilClient<ConseilGetPayload<T> | null, null>

    /**
     * Find one Conseil that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConseilFindUniqueOrThrowArgs} args - Arguments to find a Conseil
     * @example
     * // Get one Conseil
     * const conseil = await prisma.conseil.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConseilFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ConseilFindUniqueOrThrowArgs>
    ): Prisma__ConseilClient<ConseilGetPayload<T>>

    /**
     * Find the first Conseil that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConseilFindFirstArgs} args - Arguments to find a Conseil
     * @example
     * // Get one Conseil
     * const conseil = await prisma.conseil.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConseilFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ConseilFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Conseil'> extends True ? Prisma__ConseilClient<ConseilGetPayload<T>> : Prisma__ConseilClient<ConseilGetPayload<T> | null, null>

    /**
     * Find the first Conseil that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConseilFindFirstOrThrowArgs} args - Arguments to find a Conseil
     * @example
     * // Get one Conseil
     * const conseil = await prisma.conseil.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConseilFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ConseilFindFirstOrThrowArgs>
    ): Prisma__ConseilClient<ConseilGetPayload<T>>

    /**
     * Find zero or more Conseils that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConseilFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conseils
     * const conseils = await prisma.conseil.findMany()
     * 
     * // Get first 10 Conseils
     * const conseils = await prisma.conseil.findMany({ take: 10 })
     * 
     * // Only select the `id_consiel`
     * const conseilWithId_consielOnly = await prisma.conseil.findMany({ select: { id_consiel: true } })
     * 
    **/
    findMany<T extends ConseilFindManyArgs>(
      args?: SelectSubset<T, ConseilFindManyArgs>
    ): PrismaPromise<Array<ConseilGetPayload<T>>>

    /**
     * Create a Conseil.
     * @param {ConseilCreateArgs} args - Arguments to create a Conseil.
     * @example
     * // Create one Conseil
     * const Conseil = await prisma.conseil.create({
     *   data: {
     *     // ... data to create a Conseil
     *   }
     * })
     * 
    **/
    create<T extends ConseilCreateArgs>(
      args: SelectSubset<T, ConseilCreateArgs>
    ): Prisma__ConseilClient<ConseilGetPayload<T>>

    /**
     * Delete a Conseil.
     * @param {ConseilDeleteArgs} args - Arguments to delete one Conseil.
     * @example
     * // Delete one Conseil
     * const Conseil = await prisma.conseil.delete({
     *   where: {
     *     // ... filter to delete one Conseil
     *   }
     * })
     * 
    **/
    delete<T extends ConseilDeleteArgs>(
      args: SelectSubset<T, ConseilDeleteArgs>
    ): Prisma__ConseilClient<ConseilGetPayload<T>>

    /**
     * Update one Conseil.
     * @param {ConseilUpdateArgs} args - Arguments to update one Conseil.
     * @example
     * // Update one Conseil
     * const conseil = await prisma.conseil.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConseilUpdateArgs>(
      args: SelectSubset<T, ConseilUpdateArgs>
    ): Prisma__ConseilClient<ConseilGetPayload<T>>

    /**
     * Delete zero or more Conseils.
     * @param {ConseilDeleteManyArgs} args - Arguments to filter Conseils to delete.
     * @example
     * // Delete a few Conseils
     * const { count } = await prisma.conseil.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConseilDeleteManyArgs>(
      args?: SelectSubset<T, ConseilDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conseils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConseilUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conseils
     * const conseil = await prisma.conseil.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConseilUpdateManyArgs>(
      args: SelectSubset<T, ConseilUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Conseil.
     * @param {ConseilUpsertArgs} args - Arguments to update or create a Conseil.
     * @example
     * // Update or create a Conseil
     * const conseil = await prisma.conseil.upsert({
     *   create: {
     *     // ... data to create a Conseil
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conseil we want to update
     *   }
     * })
    **/
    upsert<T extends ConseilUpsertArgs>(
      args: SelectSubset<T, ConseilUpsertArgs>
    ): Prisma__ConseilClient<ConseilGetPayload<T>>

    /**
     * Count the number of Conseils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConseilCountArgs} args - Arguments to filter Conseils to count.
     * @example
     * // Count the number of Conseils
     * const count = await prisma.conseil.count({
     *   where: {
     *     // ... the filter for the Conseils we want to count
     *   }
     * })
    **/
    count<T extends ConseilCountArgs>(
      args?: Subset<T, ConseilCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConseilCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conseil.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConseilAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConseilAggregateArgs>(args: Subset<T, ConseilAggregateArgs>): PrismaPromise<GetConseilAggregateType<T>>

    /**
     * Group by Conseil.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConseilGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConseilGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConseilGroupByArgs['orderBy'] }
        : { orderBy?: ConseilGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConseilGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConseilGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Conseil.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ConseilClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Conseil base type for findUnique actions
   */
  export type ConseilFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Conseil
     */
    select?: ConseilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConseilInclude | null
    /**
     * Filter, which Conseil to fetch.
     */
    where: ConseilWhereUniqueInput
  }

  /**
   * Conseil findUnique
   */
  export interface ConseilFindUniqueArgs extends ConseilFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Conseil findUniqueOrThrow
   */
  export type ConseilFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Conseil
     */
    select?: ConseilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConseilInclude | null
    /**
     * Filter, which Conseil to fetch.
     */
    where: ConseilWhereUniqueInput
  }


  /**
   * Conseil base type for findFirst actions
   */
  export type ConseilFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Conseil
     */
    select?: ConseilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConseilInclude | null
    /**
     * Filter, which Conseil to fetch.
     */
    where?: ConseilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conseils to fetch.
     */
    orderBy?: Enumerable<ConseilOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conseils.
     */
    cursor?: ConseilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conseils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conseils.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conseils.
     */
    distinct?: Enumerable<ConseilScalarFieldEnum>
  }

  /**
   * Conseil findFirst
   */
  export interface ConseilFindFirstArgs extends ConseilFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Conseil findFirstOrThrow
   */
  export type ConseilFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Conseil
     */
    select?: ConseilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConseilInclude | null
    /**
     * Filter, which Conseil to fetch.
     */
    where?: ConseilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conseils to fetch.
     */
    orderBy?: Enumerable<ConseilOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conseils.
     */
    cursor?: ConseilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conseils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conseils.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conseils.
     */
    distinct?: Enumerable<ConseilScalarFieldEnum>
  }


  /**
   * Conseil findMany
   */
  export type ConseilFindManyArgs = {
    /**
     * Select specific fields to fetch from the Conseil
     */
    select?: ConseilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConseilInclude | null
    /**
     * Filter, which Conseils to fetch.
     */
    where?: ConseilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conseils to fetch.
     */
    orderBy?: Enumerable<ConseilOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conseils.
     */
    cursor?: ConseilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conseils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conseils.
     */
    skip?: number
    distinct?: Enumerable<ConseilScalarFieldEnum>
  }


  /**
   * Conseil create
   */
  export type ConseilCreateArgs = {
    /**
     * Select specific fields to fetch from the Conseil
     */
    select?: ConseilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConseilInclude | null
    /**
     * The data needed to create a Conseil.
     */
    data: XOR<ConseilCreateInput, ConseilUncheckedCreateInput>
  }


  /**
   * Conseil update
   */
  export type ConseilUpdateArgs = {
    /**
     * Select specific fields to fetch from the Conseil
     */
    select?: ConseilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConseilInclude | null
    /**
     * The data needed to update a Conseil.
     */
    data: XOR<ConseilUpdateInput, ConseilUncheckedUpdateInput>
    /**
     * Choose, which Conseil to update.
     */
    where: ConseilWhereUniqueInput
  }


  /**
   * Conseil updateMany
   */
  export type ConseilUpdateManyArgs = {
    /**
     * The data used to update Conseils.
     */
    data: XOR<ConseilUpdateManyMutationInput, ConseilUncheckedUpdateManyInput>
    /**
     * Filter which Conseils to update
     */
    where?: ConseilWhereInput
  }


  /**
   * Conseil upsert
   */
  export type ConseilUpsertArgs = {
    /**
     * Select specific fields to fetch from the Conseil
     */
    select?: ConseilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConseilInclude | null
    /**
     * The filter to search for the Conseil to update in case it exists.
     */
    where: ConseilWhereUniqueInput
    /**
     * In case the Conseil found by the `where` argument doesn't exist, create a new Conseil with this data.
     */
    create: XOR<ConseilCreateInput, ConseilUncheckedCreateInput>
    /**
     * In case the Conseil was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConseilUpdateInput, ConseilUncheckedUpdateInput>
  }


  /**
   * Conseil delete
   */
  export type ConseilDeleteArgs = {
    /**
     * Select specific fields to fetch from the Conseil
     */
    select?: ConseilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConseilInclude | null
    /**
     * Filter which Conseil to delete.
     */
    where: ConseilWhereUniqueInput
  }


  /**
   * Conseil deleteMany
   */
  export type ConseilDeleteManyArgs = {
    /**
     * Filter which Conseils to delete
     */
    where?: ConseilWhereInput
  }


  /**
   * Conseil without action
   */
  export type ConseilArgs = {
    /**
     * Select specific fields to fetch from the Conseil
     */
    select?: ConseilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConseilInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AnnonceScalarFieldEnum: {
    id_annonce: 'id_annonce',
    localisation: 'localisation',
    description: 'description',
    type_gardien: 'type_gardien',
    nb_signalement: 'nb_signalement',
    latidute: 'latidute',
    longitude: 'longitude',
    id_user: 'id_user'
  };

  export type AnnonceScalarFieldEnum = (typeof AnnonceScalarFieldEnum)[keyof typeof AnnonceScalarFieldEnum]


  export const BotanisteScalarFieldEnum: {
    user: 'user'
  };

  export type BotanisteScalarFieldEnum = (typeof BotanisteScalarFieldEnum)[keyof typeof BotanisteScalarFieldEnum]


  export const ConseilScalarFieldEnum: {
    id_consiel: 'id_consiel',
    date_conseil: 'date_conseil',
    message: 'message',
    idUser: 'idUser'
  };

  export type ConseilScalarFieldEnum = (typeof ConseilScalarFieldEnum)[keyof typeof ConseilScalarFieldEnum]


  export const GardiennageScalarFieldEnum: {
    id_gardiennage: 'id_gardiennage',
    date_debut: 'date_debut',
    date_fin: 'date_fin',
    description: 'description',
    id_user: 'id_user',
    idAnnonce: 'idAnnonce'
  };

  export type GardiennageScalarFieldEnum = (typeof GardiennageScalarFieldEnum)[keyof typeof GardiennageScalarFieldEnum]


  export const PhotoAnnonceScalarFieldEnum: {
    id_photo: 'id_photo',
    lien: 'lien',
    date_photo: 'date_photo',
    idAnnonce: 'idAnnonce'
  };

  export type PhotoAnnonceScalarFieldEnum = (typeof PhotoAnnonceScalarFieldEnum)[keyof typeof PhotoAnnonceScalarFieldEnum]


  export const PhotoGardiennageScalarFieldEnum: {
    id_photo: 'id_photo',
    lien: 'lien',
    date_photo: 'date_photo',
    idGardiennage: 'idGardiennage'
  };

  export type PhotoGardiennageScalarFieldEnum = (typeof PhotoGardiennageScalarFieldEnum)[keyof typeof PhotoGardiennageScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    nom: 'nom'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id_user: 'id_user',
    prenom: 'prenom',
    nom: 'nom',
    email: 'email',
    telephone: 'telephone',
    Numero_rue: 'Numero_rue',
    code_postale: 'code_postale',
    ville: 'ville',
    mdp: 'mdp',
    flag: 'flag'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const User_lambdaScalarFieldEnum: {
    user: 'user'
  };

  export type User_lambdaScalarFieldEnum = (typeof User_lambdaScalarFieldEnum)[keyof typeof User_lambdaScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type RoleWhereInput = {
    AND?: Enumerable<RoleWhereInput>
    OR?: Enumerable<RoleWhereInput>
    NOT?: Enumerable<RoleWhereInput>
    id?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    nom?: StringFilter | string
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    user?: UserOrderByWithRelationInput
    nom?: SortOrder
  }

  export type RoleWhereUniqueInput = {
    id?: number
    nom?: string
  }

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nom?: StringWithAggregatesFilter | string
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id_user?: IntFilter | number
    prenom?: StringNullableFilter | string | null
    nom?: StringFilter | string
    email?: StringFilter | string
    telephone?: StringFilter | string
    Numero_rue?: StringNullableFilter | string | null
    code_postale?: StringNullableFilter | string | null
    ville?: StringNullableFilter | string | null
    mdp?: StringNullableFilter | string | null
    flag?: IntFilter | number
    role?: XOR<RoleRelationFilter, RoleWhereInput> | null
    botanistes?: BotanisteListRelationFilter
    user_lambda?: User_lambdaListRelationFilter
    annonces?: AnnonceListRelationFilter
    gardiennages?: GardiennageListRelationFilter
    Conseil?: ConseilListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id_user?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    Numero_rue?: SortOrder
    code_postale?: SortOrder
    ville?: SortOrder
    mdp?: SortOrder
    flag?: SortOrder
    role?: RoleOrderByWithRelationInput
    botanistes?: BotanisteOrderByRelationAggregateInput
    user_lambda?: User_lambdaOrderByRelationAggregateInput
    annonces?: AnnonceOrderByRelationAggregateInput
    gardiennages?: GardiennageOrderByRelationAggregateInput
    Conseil?: ConseilOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id_user?: number
    email?: string
    telephone?: string
  }

  export type UserOrderByWithAggregationInput = {
    id_user?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    Numero_rue?: SortOrder
    code_postale?: SortOrder
    ville?: SortOrder
    mdp?: SortOrder
    flag?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id_user?: IntWithAggregatesFilter | number
    prenom?: StringNullableWithAggregatesFilter | string | null
    nom?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    telephone?: StringWithAggregatesFilter | string
    Numero_rue?: StringNullableWithAggregatesFilter | string | null
    code_postale?: StringNullableWithAggregatesFilter | string | null
    ville?: StringNullableWithAggregatesFilter | string | null
    mdp?: StringNullableWithAggregatesFilter | string | null
    flag?: IntWithAggregatesFilter | number
  }

  export type BotanisteWhereInput = {
    AND?: Enumerable<BotanisteWhereInput>
    OR?: Enumerable<BotanisteWhereInput>
    NOT?: Enumerable<BotanisteWhereInput>
    user?: IntFilter | number
    id_user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BotanisteOrderByWithRelationInput = {
    user?: SortOrder
    id_user?: UserOrderByWithRelationInput
  }

  export type BotanisteWhereUniqueInput = {
    user?: number
  }

  export type BotanisteOrderByWithAggregationInput = {
    user?: SortOrder
    _count?: BotanisteCountOrderByAggregateInput
    _avg?: BotanisteAvgOrderByAggregateInput
    _max?: BotanisteMaxOrderByAggregateInput
    _min?: BotanisteMinOrderByAggregateInput
    _sum?: BotanisteSumOrderByAggregateInput
  }

  export type BotanisteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BotanisteScalarWhereWithAggregatesInput>
    OR?: Enumerable<BotanisteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BotanisteScalarWhereWithAggregatesInput>
    user?: IntWithAggregatesFilter | number
  }

  export type User_lambdaWhereInput = {
    AND?: Enumerable<User_lambdaWhereInput>
    OR?: Enumerable<User_lambdaWhereInput>
    NOT?: Enumerable<User_lambdaWhereInput>
    user?: IntFilter | number
    id_user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type User_lambdaOrderByWithRelationInput = {
    user?: SortOrder
    id_user?: UserOrderByWithRelationInput
  }

  export type User_lambdaWhereUniqueInput = {
    user?: number
  }

  export type User_lambdaOrderByWithAggregationInput = {
    user?: SortOrder
    _count?: User_lambdaCountOrderByAggregateInput
    _avg?: User_lambdaAvgOrderByAggregateInput
    _max?: User_lambdaMaxOrderByAggregateInput
    _min?: User_lambdaMinOrderByAggregateInput
    _sum?: User_lambdaSumOrderByAggregateInput
  }

  export type User_lambdaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<User_lambdaScalarWhereWithAggregatesInput>
    OR?: Enumerable<User_lambdaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<User_lambdaScalarWhereWithAggregatesInput>
    user?: IntWithAggregatesFilter | number
  }

  export type AnnonceWhereInput = {
    AND?: Enumerable<AnnonceWhereInput>
    OR?: Enumerable<AnnonceWhereInput>
    NOT?: Enumerable<AnnonceWhereInput>
    id_annonce?: IntFilter | number
    localisation?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    type_gardien?: IntNullableFilter | number | null
    nb_signalement?: IntFilter | number
    latidute?: FloatFilter | number
    longitude?: FloatFilter | number
    id_user?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    gardiennage?: XOR<GardiennageRelationFilter, GardiennageWhereInput> | null
    photo?: PhotoAnnonceListRelationFilter
  }

  export type AnnonceOrderByWithRelationInput = {
    id_annonce?: SortOrder
    localisation?: SortOrder
    description?: SortOrder
    type_gardien?: SortOrder
    nb_signalement?: SortOrder
    latidute?: SortOrder
    longitude?: SortOrder
    id_user?: SortOrder
    user?: UserOrderByWithRelationInput
    gardiennage?: GardiennageOrderByWithRelationInput
    photo?: PhotoAnnonceOrderByRelationAggregateInput
  }

  export type AnnonceWhereUniqueInput = {
    id_annonce?: number
  }

  export type AnnonceOrderByWithAggregationInput = {
    id_annonce?: SortOrder
    localisation?: SortOrder
    description?: SortOrder
    type_gardien?: SortOrder
    nb_signalement?: SortOrder
    latidute?: SortOrder
    longitude?: SortOrder
    id_user?: SortOrder
    _count?: AnnonceCountOrderByAggregateInput
    _avg?: AnnonceAvgOrderByAggregateInput
    _max?: AnnonceMaxOrderByAggregateInput
    _min?: AnnonceMinOrderByAggregateInput
    _sum?: AnnonceSumOrderByAggregateInput
  }

  export type AnnonceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AnnonceScalarWhereWithAggregatesInput>
    OR?: Enumerable<AnnonceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AnnonceScalarWhereWithAggregatesInput>
    id_annonce?: IntWithAggregatesFilter | number
    localisation?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    type_gardien?: IntNullableWithAggregatesFilter | number | null
    nb_signalement?: IntWithAggregatesFilter | number
    latidute?: FloatWithAggregatesFilter | number
    longitude?: FloatWithAggregatesFilter | number
    id_user?: IntWithAggregatesFilter | number
  }

  export type GardiennageWhereInput = {
    AND?: Enumerable<GardiennageWhereInput>
    OR?: Enumerable<GardiennageWhereInput>
    NOT?: Enumerable<GardiennageWhereInput>
    id_gardiennage?: IntFilter | number
    date_debut?: DateTimeFilter | Date | string
    date_fin?: DateTimeFilter | Date | string
    description?: StringNullableFilter | string | null
    id_user?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    idAnnonce?: IntFilter | number
    annonce?: XOR<AnnonceRelationFilter, AnnonceWhereInput>
    photo_gardiennage?: PhotoGardiennageListRelationFilter
  }

  export type GardiennageOrderByWithRelationInput = {
    id_gardiennage?: SortOrder
    date_debut?: SortOrder
    date_fin?: SortOrder
    description?: SortOrder
    id_user?: SortOrder
    user?: UserOrderByWithRelationInput
    idAnnonce?: SortOrder
    annonce?: AnnonceOrderByWithRelationInput
    photo_gardiennage?: PhotoGardiennageOrderByRelationAggregateInput
  }

  export type GardiennageWhereUniqueInput = {
    id_gardiennage?: number
    idAnnonce?: number
  }

  export type GardiennageOrderByWithAggregationInput = {
    id_gardiennage?: SortOrder
    date_debut?: SortOrder
    date_fin?: SortOrder
    description?: SortOrder
    id_user?: SortOrder
    idAnnonce?: SortOrder
    _count?: GardiennageCountOrderByAggregateInput
    _avg?: GardiennageAvgOrderByAggregateInput
    _max?: GardiennageMaxOrderByAggregateInput
    _min?: GardiennageMinOrderByAggregateInput
    _sum?: GardiennageSumOrderByAggregateInput
  }

  export type GardiennageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GardiennageScalarWhereWithAggregatesInput>
    OR?: Enumerable<GardiennageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GardiennageScalarWhereWithAggregatesInput>
    id_gardiennage?: IntWithAggregatesFilter | number
    date_debut?: DateTimeWithAggregatesFilter | Date | string
    date_fin?: DateTimeWithAggregatesFilter | Date | string
    description?: StringNullableWithAggregatesFilter | string | null
    id_user?: IntWithAggregatesFilter | number
    idAnnonce?: IntWithAggregatesFilter | number
  }

  export type PhotoGardiennageWhereInput = {
    AND?: Enumerable<PhotoGardiennageWhereInput>
    OR?: Enumerable<PhotoGardiennageWhereInput>
    NOT?: Enumerable<PhotoGardiennageWhereInput>
    id_photo?: IntFilter | number
    lien?: StringFilter | string
    date_photo?: DateTimeFilter | Date | string
    idGardiennage?: IntFilter | number
    gardiennage?: XOR<GardiennageRelationFilter, GardiennageWhereInput>
  }

  export type PhotoGardiennageOrderByWithRelationInput = {
    id_photo?: SortOrder
    lien?: SortOrder
    date_photo?: SortOrder
    idGardiennage?: SortOrder
    gardiennage?: GardiennageOrderByWithRelationInput
  }

  export type PhotoGardiennageWhereUniqueInput = {
    id_photo?: number
  }

  export type PhotoGardiennageOrderByWithAggregationInput = {
    id_photo?: SortOrder
    lien?: SortOrder
    date_photo?: SortOrder
    idGardiennage?: SortOrder
    _count?: PhotoGardiennageCountOrderByAggregateInput
    _avg?: PhotoGardiennageAvgOrderByAggregateInput
    _max?: PhotoGardiennageMaxOrderByAggregateInput
    _min?: PhotoGardiennageMinOrderByAggregateInput
    _sum?: PhotoGardiennageSumOrderByAggregateInput
  }

  export type PhotoGardiennageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PhotoGardiennageScalarWhereWithAggregatesInput>
    OR?: Enumerable<PhotoGardiennageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PhotoGardiennageScalarWhereWithAggregatesInput>
    id_photo?: IntWithAggregatesFilter | number
    lien?: StringWithAggregatesFilter | string
    date_photo?: DateTimeWithAggregatesFilter | Date | string
    idGardiennage?: IntWithAggregatesFilter | number
  }

  export type PhotoAnnonceWhereInput = {
    AND?: Enumerable<PhotoAnnonceWhereInput>
    OR?: Enumerable<PhotoAnnonceWhereInput>
    NOT?: Enumerable<PhotoAnnonceWhereInput>
    id_photo?: IntFilter | number
    lien?: StringFilter | string
    date_photo?: DateTimeFilter | Date | string
    idAnnonce?: IntFilter | number
    annonce?: XOR<AnnonceRelationFilter, AnnonceWhereInput>
  }

  export type PhotoAnnonceOrderByWithRelationInput = {
    id_photo?: SortOrder
    lien?: SortOrder
    date_photo?: SortOrder
    idAnnonce?: SortOrder
    annonce?: AnnonceOrderByWithRelationInput
  }

  export type PhotoAnnonceWhereUniqueInput = {
    id_photo?: number
  }

  export type PhotoAnnonceOrderByWithAggregationInput = {
    id_photo?: SortOrder
    lien?: SortOrder
    date_photo?: SortOrder
    idAnnonce?: SortOrder
    _count?: PhotoAnnonceCountOrderByAggregateInput
    _avg?: PhotoAnnonceAvgOrderByAggregateInput
    _max?: PhotoAnnonceMaxOrderByAggregateInput
    _min?: PhotoAnnonceMinOrderByAggregateInput
    _sum?: PhotoAnnonceSumOrderByAggregateInput
  }

  export type PhotoAnnonceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PhotoAnnonceScalarWhereWithAggregatesInput>
    OR?: Enumerable<PhotoAnnonceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PhotoAnnonceScalarWhereWithAggregatesInput>
    id_photo?: IntWithAggregatesFilter | number
    lien?: StringWithAggregatesFilter | string
    date_photo?: DateTimeWithAggregatesFilter | Date | string
    idAnnonce?: IntWithAggregatesFilter | number
  }

  export type ConseilWhereInput = {
    AND?: Enumerable<ConseilWhereInput>
    OR?: Enumerable<ConseilWhereInput>
    NOT?: Enumerable<ConseilWhereInput>
    id_consiel?: IntFilter | number
    date_conseil?: DateTimeFilter | Date | string
    message?: StringFilter | string
    idUser?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ConseilOrderByWithRelationInput = {
    id_consiel?: SortOrder
    date_conseil?: SortOrder
    message?: SortOrder
    idUser?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ConseilWhereUniqueInput = {
    id_consiel?: number
  }

  export type ConseilOrderByWithAggregationInput = {
    id_consiel?: SortOrder
    date_conseil?: SortOrder
    message?: SortOrder
    idUser?: SortOrder
    _count?: ConseilCountOrderByAggregateInput
    _avg?: ConseilAvgOrderByAggregateInput
    _max?: ConseilMaxOrderByAggregateInput
    _min?: ConseilMinOrderByAggregateInput
    _sum?: ConseilSumOrderByAggregateInput
  }

  export type ConseilScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ConseilScalarWhereWithAggregatesInput>
    OR?: Enumerable<ConseilScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ConseilScalarWhereWithAggregatesInput>
    id_consiel?: IntWithAggregatesFilter | number
    date_conseil?: DateTimeWithAggregatesFilter | Date | string
    message?: StringWithAggregatesFilter | string
    idUser?: IntWithAggregatesFilter | number
  }

  export type RoleCreateInput = {
    user?: UserCreateNestedOneWithoutRoleInput
    nom: string
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    nom: string
  }

  export type RoleUpdateInput = {
    user?: UserUpdateOneRequiredWithoutRoleNestedInput
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    prenom?: string | null
    nom: string
    email: string
    telephone: string
    Numero_rue?: string | null
    code_postale?: string | null
    ville?: string | null
    mdp?: string | null
    flag?: number
    role?: RoleCreateNestedOneWithoutUserInput
    botanistes?: BotanisteCreateNestedManyWithoutId_userInput
    user_lambda?: User_lambdaCreateNestedManyWithoutId_userInput
    annonces?: AnnonceCreateNestedManyWithoutUserInput
    gardiennages?: GardiennageCreateNestedManyWithoutUserInput
    Conseil?: ConseilCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id_user?: number
    prenom?: string | null
    nom: string
    email: string
    telephone: string
    Numero_rue?: string | null
    code_postale?: string | null
    ville?: string | null
    mdp?: string | null
    flag?: number
    role?: RoleUncheckedCreateNestedOneWithoutUserInput
    botanistes?: BotanisteUncheckedCreateNestedManyWithoutId_userInput
    user_lambda?: User_lambdaUncheckedCreateNestedManyWithoutId_userInput
    annonces?: AnnonceUncheckedCreateNestedManyWithoutUserInput
    gardiennages?: GardiennageUncheckedCreateNestedManyWithoutUserInput
    Conseil?: ConseilUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    Numero_rue?: NullableStringFieldUpdateOperationsInput | string | null
    code_postale?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: IntFieldUpdateOperationsInput | number
    role?: RoleUpdateOneWithoutUserNestedInput
    botanistes?: BotanisteUpdateManyWithoutId_userNestedInput
    user_lambda?: User_lambdaUpdateManyWithoutId_userNestedInput
    annonces?: AnnonceUpdateManyWithoutUserNestedInput
    gardiennages?: GardiennageUpdateManyWithoutUserNestedInput
    Conseil?: ConseilUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    Numero_rue?: NullableStringFieldUpdateOperationsInput | string | null
    code_postale?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: IntFieldUpdateOperationsInput | number
    role?: RoleUncheckedUpdateOneWithoutUserNestedInput
    botanistes?: BotanisteUncheckedUpdateManyWithoutId_userNestedInput
    user_lambda?: User_lambdaUncheckedUpdateManyWithoutId_userNestedInput
    annonces?: AnnonceUncheckedUpdateManyWithoutUserNestedInput
    gardiennages?: GardiennageUncheckedUpdateManyWithoutUserNestedInput
    Conseil?: ConseilUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpdateManyMutationInput = {
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    Numero_rue?: NullableStringFieldUpdateOperationsInput | string | null
    code_postale?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: IntFieldUpdateOperationsInput | number
  }

  export type UserUncheckedUpdateManyInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    Numero_rue?: NullableStringFieldUpdateOperationsInput | string | null
    code_postale?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: IntFieldUpdateOperationsInput | number
  }

  export type BotanisteCreateInput = {
    id_user: UserCreateNestedOneWithoutBotanistesInput
  }

  export type BotanisteUncheckedCreateInput = {
    user: number
  }

  export type BotanisteUpdateInput = {
    id_user?: UserUpdateOneRequiredWithoutBotanistesNestedInput
  }

  export type BotanisteUncheckedUpdateInput = {
    user?: IntFieldUpdateOperationsInput | number
  }

  export type BotanisteUpdateManyMutationInput = {

  }

  export type BotanisteUncheckedUpdateManyInput = {
    user?: IntFieldUpdateOperationsInput | number
  }

  export type User_lambdaCreateInput = {
    id_user: UserCreateNestedOneWithoutUser_lambdaInput
  }

  export type User_lambdaUncheckedCreateInput = {
    user: number
  }

  export type User_lambdaUpdateInput = {
    id_user?: UserUpdateOneRequiredWithoutUser_lambdaNestedInput
  }

  export type User_lambdaUncheckedUpdateInput = {
    user?: IntFieldUpdateOperationsInput | number
  }

  export type User_lambdaUpdateManyMutationInput = {

  }

  export type User_lambdaUncheckedUpdateManyInput = {
    user?: IntFieldUpdateOperationsInput | number
  }

  export type AnnonceCreateInput = {
    localisation?: string | null
    description?: string | null
    type_gardien?: number | null
    nb_signalement?: number
    latidute: number
    longitude: number
    user: UserCreateNestedOneWithoutAnnoncesInput
    gardiennage?: GardiennageCreateNestedOneWithoutAnnonceInput
    photo?: PhotoAnnonceCreateNestedManyWithoutAnnonceInput
  }

  export type AnnonceUncheckedCreateInput = {
    id_annonce?: number
    localisation?: string | null
    description?: string | null
    type_gardien?: number | null
    nb_signalement?: number
    latidute: number
    longitude: number
    id_user: number
    gardiennage?: GardiennageUncheckedCreateNestedOneWithoutAnnonceInput
    photo?: PhotoAnnonceUncheckedCreateNestedManyWithoutAnnonceInput
  }

  export type AnnonceUpdateInput = {
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_gardien?: NullableIntFieldUpdateOperationsInput | number | null
    nb_signalement?: IntFieldUpdateOperationsInput | number
    latidute?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutAnnoncesNestedInput
    gardiennage?: GardiennageUpdateOneWithoutAnnonceNestedInput
    photo?: PhotoAnnonceUpdateManyWithoutAnnonceNestedInput
  }

  export type AnnonceUncheckedUpdateInput = {
    id_annonce?: IntFieldUpdateOperationsInput | number
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_gardien?: NullableIntFieldUpdateOperationsInput | number | null
    nb_signalement?: IntFieldUpdateOperationsInput | number
    latidute?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    gardiennage?: GardiennageUncheckedUpdateOneWithoutAnnonceNestedInput
    photo?: PhotoAnnonceUncheckedUpdateManyWithoutAnnonceNestedInput
  }

  export type AnnonceUpdateManyMutationInput = {
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_gardien?: NullableIntFieldUpdateOperationsInput | number | null
    nb_signalement?: IntFieldUpdateOperationsInput | number
    latidute?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type AnnonceUncheckedUpdateManyInput = {
    id_annonce?: IntFieldUpdateOperationsInput | number
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_gardien?: NullableIntFieldUpdateOperationsInput | number | null
    nb_signalement?: IntFieldUpdateOperationsInput | number
    latidute?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
  }

  export type GardiennageCreateInput = {
    date_debut: Date | string
    date_fin: Date | string
    description?: string | null
    user: UserCreateNestedOneWithoutGardiennagesInput
    annonce: AnnonceCreateNestedOneWithoutGardiennageInput
    photo_gardiennage?: PhotoGardiennageCreateNestedManyWithoutGardiennageInput
  }

  export type GardiennageUncheckedCreateInput = {
    id_gardiennage?: number
    date_debut: Date | string
    date_fin: Date | string
    description?: string | null
    id_user: number
    idAnnonce: number
    photo_gardiennage?: PhotoGardiennageUncheckedCreateNestedManyWithoutGardiennageInput
  }

  export type GardiennageUpdateInput = {
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutGardiennagesNestedInput
    annonce?: AnnonceUpdateOneRequiredWithoutGardiennageNestedInput
    photo_gardiennage?: PhotoGardiennageUpdateManyWithoutGardiennageNestedInput
  }

  export type GardiennageUncheckedUpdateInput = {
    id_gardiennage?: IntFieldUpdateOperationsInput | number
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    id_user?: IntFieldUpdateOperationsInput | number
    idAnnonce?: IntFieldUpdateOperationsInput | number
    photo_gardiennage?: PhotoGardiennageUncheckedUpdateManyWithoutGardiennageNestedInput
  }

  export type GardiennageUpdateManyMutationInput = {
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GardiennageUncheckedUpdateManyInput = {
    id_gardiennage?: IntFieldUpdateOperationsInput | number
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    id_user?: IntFieldUpdateOperationsInput | number
    idAnnonce?: IntFieldUpdateOperationsInput | number
  }

  export type PhotoGardiennageCreateInput = {
    lien: string
    date_photo: Date | string
    gardiennage: GardiennageCreateNestedOneWithoutPhoto_gardiennageInput
  }

  export type PhotoGardiennageUncheckedCreateInput = {
    id_photo?: number
    lien: string
    date_photo: Date | string
    idGardiennage: number
  }

  export type PhotoGardiennageUpdateInput = {
    lien?: StringFieldUpdateOperationsInput | string
    date_photo?: DateTimeFieldUpdateOperationsInput | Date | string
    gardiennage?: GardiennageUpdateOneRequiredWithoutPhoto_gardiennageNestedInput
  }

  export type PhotoGardiennageUncheckedUpdateInput = {
    id_photo?: IntFieldUpdateOperationsInput | number
    lien?: StringFieldUpdateOperationsInput | string
    date_photo?: DateTimeFieldUpdateOperationsInput | Date | string
    idGardiennage?: IntFieldUpdateOperationsInput | number
  }

  export type PhotoGardiennageUpdateManyMutationInput = {
    lien?: StringFieldUpdateOperationsInput | string
    date_photo?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoGardiennageUncheckedUpdateManyInput = {
    id_photo?: IntFieldUpdateOperationsInput | number
    lien?: StringFieldUpdateOperationsInput | string
    date_photo?: DateTimeFieldUpdateOperationsInput | Date | string
    idGardiennage?: IntFieldUpdateOperationsInput | number
  }

  export type PhotoAnnonceCreateInput = {
    lien: string
    date_photo: Date | string
    annonce: AnnonceCreateNestedOneWithoutPhotoInput
  }

  export type PhotoAnnonceUncheckedCreateInput = {
    id_photo?: number
    lien: string
    date_photo: Date | string
    idAnnonce: number
  }

  export type PhotoAnnonceUpdateInput = {
    lien?: StringFieldUpdateOperationsInput | string
    date_photo?: DateTimeFieldUpdateOperationsInput | Date | string
    annonce?: AnnonceUpdateOneRequiredWithoutPhotoNestedInput
  }

  export type PhotoAnnonceUncheckedUpdateInput = {
    id_photo?: IntFieldUpdateOperationsInput | number
    lien?: StringFieldUpdateOperationsInput | string
    date_photo?: DateTimeFieldUpdateOperationsInput | Date | string
    idAnnonce?: IntFieldUpdateOperationsInput | number
  }

  export type PhotoAnnonceUpdateManyMutationInput = {
    lien?: StringFieldUpdateOperationsInput | string
    date_photo?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoAnnonceUncheckedUpdateManyInput = {
    id_photo?: IntFieldUpdateOperationsInput | number
    lien?: StringFieldUpdateOperationsInput | string
    date_photo?: DateTimeFieldUpdateOperationsInput | Date | string
    idAnnonce?: IntFieldUpdateOperationsInput | number
  }

  export type ConseilCreateInput = {
    date_conseil: Date | string
    message: string
    user: UserCreateNestedOneWithoutConseilInput
  }

  export type ConseilUncheckedCreateInput = {
    id_consiel?: number
    date_conseil: Date | string
    message: string
    idUser: number
  }

  export type ConseilUpdateInput = {
    date_conseil?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutConseilNestedInput
  }

  export type ConseilUncheckedUpdateInput = {
    id_consiel?: IntFieldUpdateOperationsInput | number
    date_conseil?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    idUser?: IntFieldUpdateOperationsInput | number
  }

  export type ConseilUpdateManyMutationInput = {
    date_conseil?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type ConseilUncheckedUpdateManyInput = {
    id_consiel?: IntFieldUpdateOperationsInput | number
    date_conseil?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    idUser?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput | null
    isNot?: RoleWhereInput | null
  }

  export type BotanisteListRelationFilter = {
    every?: BotanisteWhereInput
    some?: BotanisteWhereInput
    none?: BotanisteWhereInput
  }

  export type User_lambdaListRelationFilter = {
    every?: User_lambdaWhereInput
    some?: User_lambdaWhereInput
    none?: User_lambdaWhereInput
  }

  export type AnnonceListRelationFilter = {
    every?: AnnonceWhereInput
    some?: AnnonceWhereInput
    none?: AnnonceWhereInput
  }

  export type GardiennageListRelationFilter = {
    every?: GardiennageWhereInput
    some?: GardiennageWhereInput
    none?: GardiennageWhereInput
  }

  export type ConseilListRelationFilter = {
    every?: ConseilWhereInput
    some?: ConseilWhereInput
    none?: ConseilWhereInput
  }

  export type BotanisteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type User_lambdaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnonceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GardiennageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConseilOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id_user?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    Numero_rue?: SortOrder
    code_postale?: SortOrder
    ville?: SortOrder
    mdp?: SortOrder
    flag?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id_user?: SortOrder
    flag?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id_user?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    Numero_rue?: SortOrder
    code_postale?: SortOrder
    ville?: SortOrder
    mdp?: SortOrder
    flag?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id_user?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    Numero_rue?: SortOrder
    code_postale?: SortOrder
    ville?: SortOrder
    mdp?: SortOrder
    flag?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id_user?: SortOrder
    flag?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type BotanisteCountOrderByAggregateInput = {
    user?: SortOrder
  }

  export type BotanisteAvgOrderByAggregateInput = {
    user?: SortOrder
  }

  export type BotanisteMaxOrderByAggregateInput = {
    user?: SortOrder
  }

  export type BotanisteMinOrderByAggregateInput = {
    user?: SortOrder
  }

  export type BotanisteSumOrderByAggregateInput = {
    user?: SortOrder
  }

  export type User_lambdaCountOrderByAggregateInput = {
    user?: SortOrder
  }

  export type User_lambdaAvgOrderByAggregateInput = {
    user?: SortOrder
  }

  export type User_lambdaMaxOrderByAggregateInput = {
    user?: SortOrder
  }

  export type User_lambdaMinOrderByAggregateInput = {
    user?: SortOrder
  }

  export type User_lambdaSumOrderByAggregateInput = {
    user?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type GardiennageRelationFilter = {
    is?: GardiennageWhereInput
    isNot?: GardiennageWhereInput
  }

  export type PhotoAnnonceListRelationFilter = {
    every?: PhotoAnnonceWhereInput
    some?: PhotoAnnonceWhereInput
    none?: PhotoAnnonceWhereInput
  }

  export type PhotoAnnonceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnonceCountOrderByAggregateInput = {
    id_annonce?: SortOrder
    localisation?: SortOrder
    description?: SortOrder
    type_gardien?: SortOrder
    nb_signalement?: SortOrder
    latidute?: SortOrder
    longitude?: SortOrder
    id_user?: SortOrder
  }

  export type AnnonceAvgOrderByAggregateInput = {
    id_annonce?: SortOrder
    type_gardien?: SortOrder
    nb_signalement?: SortOrder
    latidute?: SortOrder
    longitude?: SortOrder
    id_user?: SortOrder
  }

  export type AnnonceMaxOrderByAggregateInput = {
    id_annonce?: SortOrder
    localisation?: SortOrder
    description?: SortOrder
    type_gardien?: SortOrder
    nb_signalement?: SortOrder
    latidute?: SortOrder
    longitude?: SortOrder
    id_user?: SortOrder
  }

  export type AnnonceMinOrderByAggregateInput = {
    id_annonce?: SortOrder
    localisation?: SortOrder
    description?: SortOrder
    type_gardien?: SortOrder
    nb_signalement?: SortOrder
    latidute?: SortOrder
    longitude?: SortOrder
    id_user?: SortOrder
  }

  export type AnnonceSumOrderByAggregateInput = {
    id_annonce?: SortOrder
    type_gardien?: SortOrder
    nb_signalement?: SortOrder
    latidute?: SortOrder
    longitude?: SortOrder
    id_user?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type AnnonceRelationFilter = {
    is?: AnnonceWhereInput
    isNot?: AnnonceWhereInput
  }

  export type PhotoGardiennageListRelationFilter = {
    every?: PhotoGardiennageWhereInput
    some?: PhotoGardiennageWhereInput
    none?: PhotoGardiennageWhereInput
  }

  export type PhotoGardiennageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GardiennageCountOrderByAggregateInput = {
    id_gardiennage?: SortOrder
    date_debut?: SortOrder
    date_fin?: SortOrder
    description?: SortOrder
    id_user?: SortOrder
    idAnnonce?: SortOrder
  }

  export type GardiennageAvgOrderByAggregateInput = {
    id_gardiennage?: SortOrder
    id_user?: SortOrder
    idAnnonce?: SortOrder
  }

  export type GardiennageMaxOrderByAggregateInput = {
    id_gardiennage?: SortOrder
    date_debut?: SortOrder
    date_fin?: SortOrder
    description?: SortOrder
    id_user?: SortOrder
    idAnnonce?: SortOrder
  }

  export type GardiennageMinOrderByAggregateInput = {
    id_gardiennage?: SortOrder
    date_debut?: SortOrder
    date_fin?: SortOrder
    description?: SortOrder
    id_user?: SortOrder
    idAnnonce?: SortOrder
  }

  export type GardiennageSumOrderByAggregateInput = {
    id_gardiennage?: SortOrder
    id_user?: SortOrder
    idAnnonce?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type PhotoGardiennageCountOrderByAggregateInput = {
    id_photo?: SortOrder
    lien?: SortOrder
    date_photo?: SortOrder
    idGardiennage?: SortOrder
  }

  export type PhotoGardiennageAvgOrderByAggregateInput = {
    id_photo?: SortOrder
    idGardiennage?: SortOrder
  }

  export type PhotoGardiennageMaxOrderByAggregateInput = {
    id_photo?: SortOrder
    lien?: SortOrder
    date_photo?: SortOrder
    idGardiennage?: SortOrder
  }

  export type PhotoGardiennageMinOrderByAggregateInput = {
    id_photo?: SortOrder
    lien?: SortOrder
    date_photo?: SortOrder
    idGardiennage?: SortOrder
  }

  export type PhotoGardiennageSumOrderByAggregateInput = {
    id_photo?: SortOrder
    idGardiennage?: SortOrder
  }

  export type PhotoAnnonceCountOrderByAggregateInput = {
    id_photo?: SortOrder
    lien?: SortOrder
    date_photo?: SortOrder
    idAnnonce?: SortOrder
  }

  export type PhotoAnnonceAvgOrderByAggregateInput = {
    id_photo?: SortOrder
    idAnnonce?: SortOrder
  }

  export type PhotoAnnonceMaxOrderByAggregateInput = {
    id_photo?: SortOrder
    lien?: SortOrder
    date_photo?: SortOrder
    idAnnonce?: SortOrder
  }

  export type PhotoAnnonceMinOrderByAggregateInput = {
    id_photo?: SortOrder
    lien?: SortOrder
    date_photo?: SortOrder
    idAnnonce?: SortOrder
  }

  export type PhotoAnnonceSumOrderByAggregateInput = {
    id_photo?: SortOrder
    idAnnonce?: SortOrder
  }

  export type ConseilCountOrderByAggregateInput = {
    id_consiel?: SortOrder
    date_conseil?: SortOrder
    message?: SortOrder
    idUser?: SortOrder
  }

  export type ConseilAvgOrderByAggregateInput = {
    id_consiel?: SortOrder
    idUser?: SortOrder
  }

  export type ConseilMaxOrderByAggregateInput = {
    id_consiel?: SortOrder
    date_conseil?: SortOrder
    message?: SortOrder
    idUser?: SortOrder
  }

  export type ConseilMinOrderByAggregateInput = {
    id_consiel?: SortOrder
    date_conseil?: SortOrder
    message?: SortOrder
    idUser?: SortOrder
  }

  export type ConseilSumOrderByAggregateInput = {
    id_consiel?: SortOrder
    idUser?: SortOrder
  }

  export type UserCreateNestedOneWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput
    upsert?: UserUpsertWithoutRoleInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RoleCreateNestedOneWithoutUserInput = {
    create?: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput
    connect?: RoleWhereUniqueInput
  }

  export type BotanisteCreateNestedManyWithoutId_userInput = {
    create?: XOR<Enumerable<BotanisteCreateWithoutId_userInput>, Enumerable<BotanisteUncheckedCreateWithoutId_userInput>>
    connectOrCreate?: Enumerable<BotanisteCreateOrConnectWithoutId_userInput>
    connect?: Enumerable<BotanisteWhereUniqueInput>
  }

  export type User_lambdaCreateNestedManyWithoutId_userInput = {
    create?: XOR<Enumerable<User_lambdaCreateWithoutId_userInput>, Enumerable<User_lambdaUncheckedCreateWithoutId_userInput>>
    connectOrCreate?: Enumerable<User_lambdaCreateOrConnectWithoutId_userInput>
    connect?: Enumerable<User_lambdaWhereUniqueInput>
  }

  export type AnnonceCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AnnonceCreateWithoutUserInput>, Enumerable<AnnonceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AnnonceCreateOrConnectWithoutUserInput>
    connect?: Enumerable<AnnonceWhereUniqueInput>
  }

  export type GardiennageCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<GardiennageCreateWithoutUserInput>, Enumerable<GardiennageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<GardiennageCreateOrConnectWithoutUserInput>
    connect?: Enumerable<GardiennageWhereUniqueInput>
  }

  export type ConseilCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ConseilCreateWithoutUserInput>, Enumerable<ConseilUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ConseilCreateOrConnectWithoutUserInput>
    connect?: Enumerable<ConseilWhereUniqueInput>
  }

  export type RoleUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput
    connect?: RoleWhereUniqueInput
  }

  export type BotanisteUncheckedCreateNestedManyWithoutId_userInput = {
    create?: XOR<Enumerable<BotanisteCreateWithoutId_userInput>, Enumerable<BotanisteUncheckedCreateWithoutId_userInput>>
    connectOrCreate?: Enumerable<BotanisteCreateOrConnectWithoutId_userInput>
    connect?: Enumerable<BotanisteWhereUniqueInput>
  }

  export type User_lambdaUncheckedCreateNestedManyWithoutId_userInput = {
    create?: XOR<Enumerable<User_lambdaCreateWithoutId_userInput>, Enumerable<User_lambdaUncheckedCreateWithoutId_userInput>>
    connectOrCreate?: Enumerable<User_lambdaCreateOrConnectWithoutId_userInput>
    connect?: Enumerable<User_lambdaWhereUniqueInput>
  }

  export type AnnonceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AnnonceCreateWithoutUserInput>, Enumerable<AnnonceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AnnonceCreateOrConnectWithoutUserInput>
    connect?: Enumerable<AnnonceWhereUniqueInput>
  }

  export type GardiennageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<GardiennageCreateWithoutUserInput>, Enumerable<GardiennageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<GardiennageCreateOrConnectWithoutUserInput>
    connect?: Enumerable<GardiennageWhereUniqueInput>
  }

  export type ConseilUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ConseilCreateWithoutUserInput>, Enumerable<ConseilUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ConseilCreateOrConnectWithoutUserInput>
    connect?: Enumerable<ConseilWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type RoleUpdateOneWithoutUserNestedInput = {
    create?: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput
    upsert?: RoleUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<RoleUpdateWithoutUserInput, RoleUncheckedUpdateWithoutUserInput>
  }

  export type BotanisteUpdateManyWithoutId_userNestedInput = {
    create?: XOR<Enumerable<BotanisteCreateWithoutId_userInput>, Enumerable<BotanisteUncheckedCreateWithoutId_userInput>>
    connectOrCreate?: Enumerable<BotanisteCreateOrConnectWithoutId_userInput>
    set?: Enumerable<BotanisteWhereUniqueInput>
    disconnect?: Enumerable<BotanisteWhereUniqueInput>
    delete?: Enumerable<BotanisteWhereUniqueInput>
    connect?: Enumerable<BotanisteWhereUniqueInput>
    update?: Enumerable<BotanisteUpdateWithWhereUniqueWithoutId_userInput>
    updateMany?: Enumerable<BotanisteUpdateManyWithWhereWithoutId_userInput>
    deleteMany?: Enumerable<BotanisteScalarWhereInput>
  }

  export type User_lambdaUpdateManyWithoutId_userNestedInput = {
    create?: XOR<Enumerable<User_lambdaCreateWithoutId_userInput>, Enumerable<User_lambdaUncheckedCreateWithoutId_userInput>>
    connectOrCreate?: Enumerable<User_lambdaCreateOrConnectWithoutId_userInput>
    set?: Enumerable<User_lambdaWhereUniqueInput>
    disconnect?: Enumerable<User_lambdaWhereUniqueInput>
    delete?: Enumerable<User_lambdaWhereUniqueInput>
    connect?: Enumerable<User_lambdaWhereUniqueInput>
    update?: Enumerable<User_lambdaUpdateWithWhereUniqueWithoutId_userInput>
    updateMany?: Enumerable<User_lambdaUpdateManyWithWhereWithoutId_userInput>
    deleteMany?: Enumerable<User_lambdaScalarWhereInput>
  }

  export type AnnonceUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AnnonceCreateWithoutUserInput>, Enumerable<AnnonceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AnnonceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AnnonceUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<AnnonceWhereUniqueInput>
    disconnect?: Enumerable<AnnonceWhereUniqueInput>
    delete?: Enumerable<AnnonceWhereUniqueInput>
    connect?: Enumerable<AnnonceWhereUniqueInput>
    update?: Enumerable<AnnonceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AnnonceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AnnonceScalarWhereInput>
  }

  export type GardiennageUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<GardiennageCreateWithoutUserInput>, Enumerable<GardiennageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<GardiennageCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<GardiennageUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<GardiennageWhereUniqueInput>
    disconnect?: Enumerable<GardiennageWhereUniqueInput>
    delete?: Enumerable<GardiennageWhereUniqueInput>
    connect?: Enumerable<GardiennageWhereUniqueInput>
    update?: Enumerable<GardiennageUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<GardiennageUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<GardiennageScalarWhereInput>
  }

  export type ConseilUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ConseilCreateWithoutUserInput>, Enumerable<ConseilUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ConseilCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ConseilUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<ConseilWhereUniqueInput>
    disconnect?: Enumerable<ConseilWhereUniqueInput>
    delete?: Enumerable<ConseilWhereUniqueInput>
    connect?: Enumerable<ConseilWhereUniqueInput>
    update?: Enumerable<ConseilUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ConseilUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ConseilScalarWhereInput>
  }

  export type RoleUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserInput
    upsert?: RoleUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<RoleUpdateWithoutUserInput, RoleUncheckedUpdateWithoutUserInput>
  }

  export type BotanisteUncheckedUpdateManyWithoutId_userNestedInput = {
    create?: XOR<Enumerable<BotanisteCreateWithoutId_userInput>, Enumerable<BotanisteUncheckedCreateWithoutId_userInput>>
    connectOrCreate?: Enumerable<BotanisteCreateOrConnectWithoutId_userInput>
    set?: Enumerable<BotanisteWhereUniqueInput>
    disconnect?: Enumerable<BotanisteWhereUniqueInput>
    delete?: Enumerable<BotanisteWhereUniqueInput>
    connect?: Enumerable<BotanisteWhereUniqueInput>
    update?: Enumerable<BotanisteUpdateWithWhereUniqueWithoutId_userInput>
    updateMany?: Enumerable<BotanisteUpdateManyWithWhereWithoutId_userInput>
    deleteMany?: Enumerable<BotanisteScalarWhereInput>
  }

  export type User_lambdaUncheckedUpdateManyWithoutId_userNestedInput = {
    create?: XOR<Enumerable<User_lambdaCreateWithoutId_userInput>, Enumerable<User_lambdaUncheckedCreateWithoutId_userInput>>
    connectOrCreate?: Enumerable<User_lambdaCreateOrConnectWithoutId_userInput>
    set?: Enumerable<User_lambdaWhereUniqueInput>
    disconnect?: Enumerable<User_lambdaWhereUniqueInput>
    delete?: Enumerable<User_lambdaWhereUniqueInput>
    connect?: Enumerable<User_lambdaWhereUniqueInput>
    update?: Enumerable<User_lambdaUpdateWithWhereUniqueWithoutId_userInput>
    updateMany?: Enumerable<User_lambdaUpdateManyWithWhereWithoutId_userInput>
    deleteMany?: Enumerable<User_lambdaScalarWhereInput>
  }

  export type AnnonceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AnnonceCreateWithoutUserInput>, Enumerable<AnnonceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AnnonceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AnnonceUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<AnnonceWhereUniqueInput>
    disconnect?: Enumerable<AnnonceWhereUniqueInput>
    delete?: Enumerable<AnnonceWhereUniqueInput>
    connect?: Enumerable<AnnonceWhereUniqueInput>
    update?: Enumerable<AnnonceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AnnonceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AnnonceScalarWhereInput>
  }

  export type GardiennageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<GardiennageCreateWithoutUserInput>, Enumerable<GardiennageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<GardiennageCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<GardiennageUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<GardiennageWhereUniqueInput>
    disconnect?: Enumerable<GardiennageWhereUniqueInput>
    delete?: Enumerable<GardiennageWhereUniqueInput>
    connect?: Enumerable<GardiennageWhereUniqueInput>
    update?: Enumerable<GardiennageUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<GardiennageUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<GardiennageScalarWhereInput>
  }

  export type ConseilUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ConseilCreateWithoutUserInput>, Enumerable<ConseilUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ConseilCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ConseilUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<ConseilWhereUniqueInput>
    disconnect?: Enumerable<ConseilWhereUniqueInput>
    delete?: Enumerable<ConseilWhereUniqueInput>
    connect?: Enumerable<ConseilWhereUniqueInput>
    update?: Enumerable<ConseilUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ConseilUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ConseilScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutBotanistesInput = {
    create?: XOR<UserCreateWithoutBotanistesInput, UserUncheckedCreateWithoutBotanistesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBotanistesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBotanistesNestedInput = {
    create?: XOR<UserCreateWithoutBotanistesInput, UserUncheckedCreateWithoutBotanistesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBotanistesInput
    upsert?: UserUpsertWithoutBotanistesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutBotanistesInput, UserUncheckedUpdateWithoutBotanistesInput>
  }

  export type UserCreateNestedOneWithoutUser_lambdaInput = {
    create?: XOR<UserCreateWithoutUser_lambdaInput, UserUncheckedCreateWithoutUser_lambdaInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_lambdaInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUser_lambdaNestedInput = {
    create?: XOR<UserCreateWithoutUser_lambdaInput, UserUncheckedCreateWithoutUser_lambdaInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_lambdaInput
    upsert?: UserUpsertWithoutUser_lambdaInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUser_lambdaInput, UserUncheckedUpdateWithoutUser_lambdaInput>
  }

  export type UserCreateNestedOneWithoutAnnoncesInput = {
    create?: XOR<UserCreateWithoutAnnoncesInput, UserUncheckedCreateWithoutAnnoncesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnoncesInput
    connect?: UserWhereUniqueInput
  }

  export type GardiennageCreateNestedOneWithoutAnnonceInput = {
    create?: XOR<GardiennageCreateWithoutAnnonceInput, GardiennageUncheckedCreateWithoutAnnonceInput>
    connectOrCreate?: GardiennageCreateOrConnectWithoutAnnonceInput
    connect?: GardiennageWhereUniqueInput
  }

  export type PhotoAnnonceCreateNestedManyWithoutAnnonceInput = {
    create?: XOR<Enumerable<PhotoAnnonceCreateWithoutAnnonceInput>, Enumerable<PhotoAnnonceUncheckedCreateWithoutAnnonceInput>>
    connectOrCreate?: Enumerable<PhotoAnnonceCreateOrConnectWithoutAnnonceInput>
    connect?: Enumerable<PhotoAnnonceWhereUniqueInput>
  }

  export type GardiennageUncheckedCreateNestedOneWithoutAnnonceInput = {
    create?: XOR<GardiennageCreateWithoutAnnonceInput, GardiennageUncheckedCreateWithoutAnnonceInput>
    connectOrCreate?: GardiennageCreateOrConnectWithoutAnnonceInput
    connect?: GardiennageWhereUniqueInput
  }

  export type PhotoAnnonceUncheckedCreateNestedManyWithoutAnnonceInput = {
    create?: XOR<Enumerable<PhotoAnnonceCreateWithoutAnnonceInput>, Enumerable<PhotoAnnonceUncheckedCreateWithoutAnnonceInput>>
    connectOrCreate?: Enumerable<PhotoAnnonceCreateOrConnectWithoutAnnonceInput>
    connect?: Enumerable<PhotoAnnonceWhereUniqueInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAnnoncesNestedInput = {
    create?: XOR<UserCreateWithoutAnnoncesInput, UserUncheckedCreateWithoutAnnoncesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnnoncesInput
    upsert?: UserUpsertWithoutAnnoncesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAnnoncesInput, UserUncheckedUpdateWithoutAnnoncesInput>
  }

  export type GardiennageUpdateOneWithoutAnnonceNestedInput = {
    create?: XOR<GardiennageCreateWithoutAnnonceInput, GardiennageUncheckedCreateWithoutAnnonceInput>
    connectOrCreate?: GardiennageCreateOrConnectWithoutAnnonceInput
    upsert?: GardiennageUpsertWithoutAnnonceInput
    disconnect?: boolean
    delete?: boolean
    connect?: GardiennageWhereUniqueInput
    update?: XOR<GardiennageUpdateWithoutAnnonceInput, GardiennageUncheckedUpdateWithoutAnnonceInput>
  }

  export type PhotoAnnonceUpdateManyWithoutAnnonceNestedInput = {
    create?: XOR<Enumerable<PhotoAnnonceCreateWithoutAnnonceInput>, Enumerable<PhotoAnnonceUncheckedCreateWithoutAnnonceInput>>
    connectOrCreate?: Enumerable<PhotoAnnonceCreateOrConnectWithoutAnnonceInput>
    upsert?: Enumerable<PhotoAnnonceUpsertWithWhereUniqueWithoutAnnonceInput>
    set?: Enumerable<PhotoAnnonceWhereUniqueInput>
    disconnect?: Enumerable<PhotoAnnonceWhereUniqueInput>
    delete?: Enumerable<PhotoAnnonceWhereUniqueInput>
    connect?: Enumerable<PhotoAnnonceWhereUniqueInput>
    update?: Enumerable<PhotoAnnonceUpdateWithWhereUniqueWithoutAnnonceInput>
    updateMany?: Enumerable<PhotoAnnonceUpdateManyWithWhereWithoutAnnonceInput>
    deleteMany?: Enumerable<PhotoAnnonceScalarWhereInput>
  }

  export type GardiennageUncheckedUpdateOneWithoutAnnonceNestedInput = {
    create?: XOR<GardiennageCreateWithoutAnnonceInput, GardiennageUncheckedCreateWithoutAnnonceInput>
    connectOrCreate?: GardiennageCreateOrConnectWithoutAnnonceInput
    upsert?: GardiennageUpsertWithoutAnnonceInput
    disconnect?: boolean
    delete?: boolean
    connect?: GardiennageWhereUniqueInput
    update?: XOR<GardiennageUpdateWithoutAnnonceInput, GardiennageUncheckedUpdateWithoutAnnonceInput>
  }

  export type PhotoAnnonceUncheckedUpdateManyWithoutAnnonceNestedInput = {
    create?: XOR<Enumerable<PhotoAnnonceCreateWithoutAnnonceInput>, Enumerable<PhotoAnnonceUncheckedCreateWithoutAnnonceInput>>
    connectOrCreate?: Enumerable<PhotoAnnonceCreateOrConnectWithoutAnnonceInput>
    upsert?: Enumerable<PhotoAnnonceUpsertWithWhereUniqueWithoutAnnonceInput>
    set?: Enumerable<PhotoAnnonceWhereUniqueInput>
    disconnect?: Enumerable<PhotoAnnonceWhereUniqueInput>
    delete?: Enumerable<PhotoAnnonceWhereUniqueInput>
    connect?: Enumerable<PhotoAnnonceWhereUniqueInput>
    update?: Enumerable<PhotoAnnonceUpdateWithWhereUniqueWithoutAnnonceInput>
    updateMany?: Enumerable<PhotoAnnonceUpdateManyWithWhereWithoutAnnonceInput>
    deleteMany?: Enumerable<PhotoAnnonceScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutGardiennagesInput = {
    create?: XOR<UserCreateWithoutGardiennagesInput, UserUncheckedCreateWithoutGardiennagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGardiennagesInput
    connect?: UserWhereUniqueInput
  }

  export type AnnonceCreateNestedOneWithoutGardiennageInput = {
    create?: XOR<AnnonceCreateWithoutGardiennageInput, AnnonceUncheckedCreateWithoutGardiennageInput>
    connectOrCreate?: AnnonceCreateOrConnectWithoutGardiennageInput
    connect?: AnnonceWhereUniqueInput
  }

  export type PhotoGardiennageCreateNestedManyWithoutGardiennageInput = {
    create?: XOR<Enumerable<PhotoGardiennageCreateWithoutGardiennageInput>, Enumerable<PhotoGardiennageUncheckedCreateWithoutGardiennageInput>>
    connectOrCreate?: Enumerable<PhotoGardiennageCreateOrConnectWithoutGardiennageInput>
    connect?: Enumerable<PhotoGardiennageWhereUniqueInput>
  }

  export type PhotoGardiennageUncheckedCreateNestedManyWithoutGardiennageInput = {
    create?: XOR<Enumerable<PhotoGardiennageCreateWithoutGardiennageInput>, Enumerable<PhotoGardiennageUncheckedCreateWithoutGardiennageInput>>
    connectOrCreate?: Enumerable<PhotoGardiennageCreateOrConnectWithoutGardiennageInput>
    connect?: Enumerable<PhotoGardiennageWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutGardiennagesNestedInput = {
    create?: XOR<UserCreateWithoutGardiennagesInput, UserUncheckedCreateWithoutGardiennagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGardiennagesInput
    upsert?: UserUpsertWithoutGardiennagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutGardiennagesInput, UserUncheckedUpdateWithoutGardiennagesInput>
  }

  export type AnnonceUpdateOneRequiredWithoutGardiennageNestedInput = {
    create?: XOR<AnnonceCreateWithoutGardiennageInput, AnnonceUncheckedCreateWithoutGardiennageInput>
    connectOrCreate?: AnnonceCreateOrConnectWithoutGardiennageInput
    upsert?: AnnonceUpsertWithoutGardiennageInput
    connect?: AnnonceWhereUniqueInput
    update?: XOR<AnnonceUpdateWithoutGardiennageInput, AnnonceUncheckedUpdateWithoutGardiennageInput>
  }

  export type PhotoGardiennageUpdateManyWithoutGardiennageNestedInput = {
    create?: XOR<Enumerable<PhotoGardiennageCreateWithoutGardiennageInput>, Enumerable<PhotoGardiennageUncheckedCreateWithoutGardiennageInput>>
    connectOrCreate?: Enumerable<PhotoGardiennageCreateOrConnectWithoutGardiennageInput>
    upsert?: Enumerable<PhotoGardiennageUpsertWithWhereUniqueWithoutGardiennageInput>
    set?: Enumerable<PhotoGardiennageWhereUniqueInput>
    disconnect?: Enumerable<PhotoGardiennageWhereUniqueInput>
    delete?: Enumerable<PhotoGardiennageWhereUniqueInput>
    connect?: Enumerable<PhotoGardiennageWhereUniqueInput>
    update?: Enumerable<PhotoGardiennageUpdateWithWhereUniqueWithoutGardiennageInput>
    updateMany?: Enumerable<PhotoGardiennageUpdateManyWithWhereWithoutGardiennageInput>
    deleteMany?: Enumerable<PhotoGardiennageScalarWhereInput>
  }

  export type PhotoGardiennageUncheckedUpdateManyWithoutGardiennageNestedInput = {
    create?: XOR<Enumerable<PhotoGardiennageCreateWithoutGardiennageInput>, Enumerable<PhotoGardiennageUncheckedCreateWithoutGardiennageInput>>
    connectOrCreate?: Enumerable<PhotoGardiennageCreateOrConnectWithoutGardiennageInput>
    upsert?: Enumerable<PhotoGardiennageUpsertWithWhereUniqueWithoutGardiennageInput>
    set?: Enumerable<PhotoGardiennageWhereUniqueInput>
    disconnect?: Enumerable<PhotoGardiennageWhereUniqueInput>
    delete?: Enumerable<PhotoGardiennageWhereUniqueInput>
    connect?: Enumerable<PhotoGardiennageWhereUniqueInput>
    update?: Enumerable<PhotoGardiennageUpdateWithWhereUniqueWithoutGardiennageInput>
    updateMany?: Enumerable<PhotoGardiennageUpdateManyWithWhereWithoutGardiennageInput>
    deleteMany?: Enumerable<PhotoGardiennageScalarWhereInput>
  }

  export type GardiennageCreateNestedOneWithoutPhoto_gardiennageInput = {
    create?: XOR<GardiennageCreateWithoutPhoto_gardiennageInput, GardiennageUncheckedCreateWithoutPhoto_gardiennageInput>
    connectOrCreate?: GardiennageCreateOrConnectWithoutPhoto_gardiennageInput
    connect?: GardiennageWhereUniqueInput
  }

  export type GardiennageUpdateOneRequiredWithoutPhoto_gardiennageNestedInput = {
    create?: XOR<GardiennageCreateWithoutPhoto_gardiennageInput, GardiennageUncheckedCreateWithoutPhoto_gardiennageInput>
    connectOrCreate?: GardiennageCreateOrConnectWithoutPhoto_gardiennageInput
    upsert?: GardiennageUpsertWithoutPhoto_gardiennageInput
    connect?: GardiennageWhereUniqueInput
    update?: XOR<GardiennageUpdateWithoutPhoto_gardiennageInput, GardiennageUncheckedUpdateWithoutPhoto_gardiennageInput>
  }

  export type AnnonceCreateNestedOneWithoutPhotoInput = {
    create?: XOR<AnnonceCreateWithoutPhotoInput, AnnonceUncheckedCreateWithoutPhotoInput>
    connectOrCreate?: AnnonceCreateOrConnectWithoutPhotoInput
    connect?: AnnonceWhereUniqueInput
  }

  export type AnnonceUpdateOneRequiredWithoutPhotoNestedInput = {
    create?: XOR<AnnonceCreateWithoutPhotoInput, AnnonceUncheckedCreateWithoutPhotoInput>
    connectOrCreate?: AnnonceCreateOrConnectWithoutPhotoInput
    upsert?: AnnonceUpsertWithoutPhotoInput
    connect?: AnnonceWhereUniqueInput
    update?: XOR<AnnonceUpdateWithoutPhotoInput, AnnonceUncheckedUpdateWithoutPhotoInput>
  }

  export type UserCreateNestedOneWithoutConseilInput = {
    create?: XOR<UserCreateWithoutConseilInput, UserUncheckedCreateWithoutConseilInput>
    connectOrCreate?: UserCreateOrConnectWithoutConseilInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutConseilNestedInput = {
    create?: XOR<UserCreateWithoutConseilInput, UserUncheckedCreateWithoutConseilInput>
    connectOrCreate?: UserCreateOrConnectWithoutConseilInput
    upsert?: UserUpsertWithoutConseilInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutConseilInput, UserUncheckedUpdateWithoutConseilInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type UserCreateWithoutRoleInput = {
    prenom?: string | null
    nom: string
    email: string
    telephone: string
    Numero_rue?: string | null
    code_postale?: string | null
    ville?: string | null
    mdp?: string | null
    flag?: number
    botanistes?: BotanisteCreateNestedManyWithoutId_userInput
    user_lambda?: User_lambdaCreateNestedManyWithoutId_userInput
    annonces?: AnnonceCreateNestedManyWithoutUserInput
    gardiennages?: GardiennageCreateNestedManyWithoutUserInput
    Conseil?: ConseilCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id_user?: number
    prenom?: string | null
    nom: string
    email: string
    telephone: string
    Numero_rue?: string | null
    code_postale?: string | null
    ville?: string | null
    mdp?: string | null
    flag?: number
    botanistes?: BotanisteUncheckedCreateNestedManyWithoutId_userInput
    user_lambda?: User_lambdaUncheckedCreateNestedManyWithoutId_userInput
    annonces?: AnnonceUncheckedCreateNestedManyWithoutUserInput
    gardiennages?: GardiennageUncheckedCreateNestedManyWithoutUserInput
    Conseil?: ConseilUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpsertWithoutRoleInput = {
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithoutRoleInput = {
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    Numero_rue?: NullableStringFieldUpdateOperationsInput | string | null
    code_postale?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: IntFieldUpdateOperationsInput | number
    botanistes?: BotanisteUpdateManyWithoutId_userNestedInput
    user_lambda?: User_lambdaUpdateManyWithoutId_userNestedInput
    annonces?: AnnonceUpdateManyWithoutUserNestedInput
    gardiennages?: GardiennageUpdateManyWithoutUserNestedInput
    Conseil?: ConseilUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    Numero_rue?: NullableStringFieldUpdateOperationsInput | string | null
    code_postale?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: IntFieldUpdateOperationsInput | number
    botanistes?: BotanisteUncheckedUpdateManyWithoutId_userNestedInput
    user_lambda?: User_lambdaUncheckedUpdateManyWithoutId_userNestedInput
    annonces?: AnnonceUncheckedUpdateManyWithoutUserNestedInput
    gardiennages?: GardiennageUncheckedUpdateManyWithoutUserNestedInput
    Conseil?: ConseilUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoleCreateWithoutUserInput = {
    nom: string
  }

  export type RoleUncheckedCreateWithoutUserInput = {
    nom: string
  }

  export type RoleCreateOrConnectWithoutUserInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
  }

  export type BotanisteCreateWithoutId_userInput = {

  }

  export type BotanisteUncheckedCreateWithoutId_userInput = {

  }

  export type BotanisteCreateOrConnectWithoutId_userInput = {
    where: BotanisteWhereUniqueInput
    create: XOR<BotanisteCreateWithoutId_userInput, BotanisteUncheckedCreateWithoutId_userInput>
  }

  export type User_lambdaCreateWithoutId_userInput = {

  }

  export type User_lambdaUncheckedCreateWithoutId_userInput = {

  }

  export type User_lambdaCreateOrConnectWithoutId_userInput = {
    where: User_lambdaWhereUniqueInput
    create: XOR<User_lambdaCreateWithoutId_userInput, User_lambdaUncheckedCreateWithoutId_userInput>
  }

  export type AnnonceCreateWithoutUserInput = {
    localisation?: string | null
    description?: string | null
    type_gardien?: number | null
    nb_signalement?: number
    latidute: number
    longitude: number
    gardiennage?: GardiennageCreateNestedOneWithoutAnnonceInput
    photo?: PhotoAnnonceCreateNestedManyWithoutAnnonceInput
  }

  export type AnnonceUncheckedCreateWithoutUserInput = {
    id_annonce?: number
    localisation?: string | null
    description?: string | null
    type_gardien?: number | null
    nb_signalement?: number
    latidute: number
    longitude: number
    gardiennage?: GardiennageUncheckedCreateNestedOneWithoutAnnonceInput
    photo?: PhotoAnnonceUncheckedCreateNestedManyWithoutAnnonceInput
  }

  export type AnnonceCreateOrConnectWithoutUserInput = {
    where: AnnonceWhereUniqueInput
    create: XOR<AnnonceCreateWithoutUserInput, AnnonceUncheckedCreateWithoutUserInput>
  }

  export type GardiennageCreateWithoutUserInput = {
    date_debut: Date | string
    date_fin: Date | string
    description?: string | null
    annonce: AnnonceCreateNestedOneWithoutGardiennageInput
    photo_gardiennage?: PhotoGardiennageCreateNestedManyWithoutGardiennageInput
  }

  export type GardiennageUncheckedCreateWithoutUserInput = {
    id_gardiennage?: number
    date_debut: Date | string
    date_fin: Date | string
    description?: string | null
    idAnnonce: number
    photo_gardiennage?: PhotoGardiennageUncheckedCreateNestedManyWithoutGardiennageInput
  }

  export type GardiennageCreateOrConnectWithoutUserInput = {
    where: GardiennageWhereUniqueInput
    create: XOR<GardiennageCreateWithoutUserInput, GardiennageUncheckedCreateWithoutUserInput>
  }

  export type ConseilCreateWithoutUserInput = {
    date_conseil: Date | string
    message: string
  }

  export type ConseilUncheckedCreateWithoutUserInput = {
    id_consiel?: number
    date_conseil: Date | string
    message: string
  }

  export type ConseilCreateOrConnectWithoutUserInput = {
    where: ConseilWhereUniqueInput
    create: XOR<ConseilCreateWithoutUserInput, ConseilUncheckedCreateWithoutUserInput>
  }

  export type RoleUpsertWithoutUserInput = {
    update: XOR<RoleUpdateWithoutUserInput, RoleUncheckedUpdateWithoutUserInput>
    create: XOR<RoleCreateWithoutUserInput, RoleUncheckedCreateWithoutUserInput>
  }

  export type RoleUpdateWithoutUserInput = {
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateWithoutUserInput = {
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type BotanisteUpdateWithWhereUniqueWithoutId_userInput = {
    where: BotanisteWhereUniqueInput
    data: XOR<BotanisteUpdateWithoutId_userInput, BotanisteUncheckedUpdateWithoutId_userInput>
  }

  export type BotanisteUpdateManyWithWhereWithoutId_userInput = {
    where: BotanisteScalarWhereInput
    data: XOR<BotanisteUpdateManyMutationInput, BotanisteUncheckedUpdateManyWithoutBotanistesInput>
  }

  export type BotanisteScalarWhereInput = {
    AND?: Enumerable<BotanisteScalarWhereInput>
    OR?: Enumerable<BotanisteScalarWhereInput>
    NOT?: Enumerable<BotanisteScalarWhereInput>
    user?: IntFilter | number
  }

  export type User_lambdaUpdateWithWhereUniqueWithoutId_userInput = {
    where: User_lambdaWhereUniqueInput
    data: XOR<User_lambdaUpdateWithoutId_userInput, User_lambdaUncheckedUpdateWithoutId_userInput>
  }

  export type User_lambdaUpdateManyWithWhereWithoutId_userInput = {
    where: User_lambdaScalarWhereInput
    data: XOR<User_lambdaUpdateManyMutationInput, User_lambdaUncheckedUpdateManyWithoutUser_lambdaInput>
  }

  export type User_lambdaScalarWhereInput = {
    AND?: Enumerable<User_lambdaScalarWhereInput>
    OR?: Enumerable<User_lambdaScalarWhereInput>
    NOT?: Enumerable<User_lambdaScalarWhereInput>
    user?: IntFilter | number
  }

  export type AnnonceUpsertWithWhereUniqueWithoutUserInput = {
    where: AnnonceWhereUniqueInput
    update: XOR<AnnonceUpdateWithoutUserInput, AnnonceUncheckedUpdateWithoutUserInput>
    create: XOR<AnnonceCreateWithoutUserInput, AnnonceUncheckedCreateWithoutUserInput>
  }

  export type AnnonceUpdateWithWhereUniqueWithoutUserInput = {
    where: AnnonceWhereUniqueInput
    data: XOR<AnnonceUpdateWithoutUserInput, AnnonceUncheckedUpdateWithoutUserInput>
  }

  export type AnnonceUpdateManyWithWhereWithoutUserInput = {
    where: AnnonceScalarWhereInput
    data: XOR<AnnonceUpdateManyMutationInput, AnnonceUncheckedUpdateManyWithoutAnnoncesInput>
  }

  export type AnnonceScalarWhereInput = {
    AND?: Enumerable<AnnonceScalarWhereInput>
    OR?: Enumerable<AnnonceScalarWhereInput>
    NOT?: Enumerable<AnnonceScalarWhereInput>
    id_annonce?: IntFilter | number
    localisation?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    type_gardien?: IntNullableFilter | number | null
    nb_signalement?: IntFilter | number
    latidute?: FloatFilter | number
    longitude?: FloatFilter | number
    id_user?: IntFilter | number
  }

  export type GardiennageUpsertWithWhereUniqueWithoutUserInput = {
    where: GardiennageWhereUniqueInput
    update: XOR<GardiennageUpdateWithoutUserInput, GardiennageUncheckedUpdateWithoutUserInput>
    create: XOR<GardiennageCreateWithoutUserInput, GardiennageUncheckedCreateWithoutUserInput>
  }

  export type GardiennageUpdateWithWhereUniqueWithoutUserInput = {
    where: GardiennageWhereUniqueInput
    data: XOR<GardiennageUpdateWithoutUserInput, GardiennageUncheckedUpdateWithoutUserInput>
  }

  export type GardiennageUpdateManyWithWhereWithoutUserInput = {
    where: GardiennageScalarWhereInput
    data: XOR<GardiennageUpdateManyMutationInput, GardiennageUncheckedUpdateManyWithoutGardiennagesInput>
  }

  export type GardiennageScalarWhereInput = {
    AND?: Enumerable<GardiennageScalarWhereInput>
    OR?: Enumerable<GardiennageScalarWhereInput>
    NOT?: Enumerable<GardiennageScalarWhereInput>
    id_gardiennage?: IntFilter | number
    date_debut?: DateTimeFilter | Date | string
    date_fin?: DateTimeFilter | Date | string
    description?: StringNullableFilter | string | null
    id_user?: IntFilter | number
    idAnnonce?: IntFilter | number
  }

  export type ConseilUpsertWithWhereUniqueWithoutUserInput = {
    where: ConseilWhereUniqueInput
    update: XOR<ConseilUpdateWithoutUserInput, ConseilUncheckedUpdateWithoutUserInput>
    create: XOR<ConseilCreateWithoutUserInput, ConseilUncheckedCreateWithoutUserInput>
  }

  export type ConseilUpdateWithWhereUniqueWithoutUserInput = {
    where: ConseilWhereUniqueInput
    data: XOR<ConseilUpdateWithoutUserInput, ConseilUncheckedUpdateWithoutUserInput>
  }

  export type ConseilUpdateManyWithWhereWithoutUserInput = {
    where: ConseilScalarWhereInput
    data: XOR<ConseilUpdateManyMutationInput, ConseilUncheckedUpdateManyWithoutConseilInput>
  }

  export type ConseilScalarWhereInput = {
    AND?: Enumerable<ConseilScalarWhereInput>
    OR?: Enumerable<ConseilScalarWhereInput>
    NOT?: Enumerable<ConseilScalarWhereInput>
    id_consiel?: IntFilter | number
    date_conseil?: DateTimeFilter | Date | string
    message?: StringFilter | string
    idUser?: IntFilter | number
  }

  export type UserCreateWithoutBotanistesInput = {
    prenom?: string | null
    nom: string
    email: string
    telephone: string
    Numero_rue?: string | null
    code_postale?: string | null
    ville?: string | null
    mdp?: string | null
    flag?: number
    role?: RoleCreateNestedOneWithoutUserInput
    user_lambda?: User_lambdaCreateNestedManyWithoutId_userInput
    annonces?: AnnonceCreateNestedManyWithoutUserInput
    gardiennages?: GardiennageCreateNestedManyWithoutUserInput
    Conseil?: ConseilCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBotanistesInput = {
    id_user?: number
    prenom?: string | null
    nom: string
    email: string
    telephone: string
    Numero_rue?: string | null
    code_postale?: string | null
    ville?: string | null
    mdp?: string | null
    flag?: number
    role?: RoleUncheckedCreateNestedOneWithoutUserInput
    user_lambda?: User_lambdaUncheckedCreateNestedManyWithoutId_userInput
    annonces?: AnnonceUncheckedCreateNestedManyWithoutUserInput
    gardiennages?: GardiennageUncheckedCreateNestedManyWithoutUserInput
    Conseil?: ConseilUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBotanistesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBotanistesInput, UserUncheckedCreateWithoutBotanistesInput>
  }

  export type UserUpsertWithoutBotanistesInput = {
    update: XOR<UserUpdateWithoutBotanistesInput, UserUncheckedUpdateWithoutBotanistesInput>
    create: XOR<UserCreateWithoutBotanistesInput, UserUncheckedCreateWithoutBotanistesInput>
  }

  export type UserUpdateWithoutBotanistesInput = {
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    Numero_rue?: NullableStringFieldUpdateOperationsInput | string | null
    code_postale?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: IntFieldUpdateOperationsInput | number
    role?: RoleUpdateOneWithoutUserNestedInput
    user_lambda?: User_lambdaUpdateManyWithoutId_userNestedInput
    annonces?: AnnonceUpdateManyWithoutUserNestedInput
    gardiennages?: GardiennageUpdateManyWithoutUserNestedInput
    Conseil?: ConseilUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBotanistesInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    Numero_rue?: NullableStringFieldUpdateOperationsInput | string | null
    code_postale?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: IntFieldUpdateOperationsInput | number
    role?: RoleUncheckedUpdateOneWithoutUserNestedInput
    user_lambda?: User_lambdaUncheckedUpdateManyWithoutId_userNestedInput
    annonces?: AnnonceUncheckedUpdateManyWithoutUserNestedInput
    gardiennages?: GardiennageUncheckedUpdateManyWithoutUserNestedInput
    Conseil?: ConseilUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUser_lambdaInput = {
    prenom?: string | null
    nom: string
    email: string
    telephone: string
    Numero_rue?: string | null
    code_postale?: string | null
    ville?: string | null
    mdp?: string | null
    flag?: number
    role?: RoleCreateNestedOneWithoutUserInput
    botanistes?: BotanisteCreateNestedManyWithoutId_userInput
    annonces?: AnnonceCreateNestedManyWithoutUserInput
    gardiennages?: GardiennageCreateNestedManyWithoutUserInput
    Conseil?: ConseilCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_lambdaInput = {
    id_user?: number
    prenom?: string | null
    nom: string
    email: string
    telephone: string
    Numero_rue?: string | null
    code_postale?: string | null
    ville?: string | null
    mdp?: string | null
    flag?: number
    role?: RoleUncheckedCreateNestedOneWithoutUserInput
    botanistes?: BotanisteUncheckedCreateNestedManyWithoutId_userInput
    annonces?: AnnonceUncheckedCreateNestedManyWithoutUserInput
    gardiennages?: GardiennageUncheckedCreateNestedManyWithoutUserInput
    Conseil?: ConseilUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_lambdaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_lambdaInput, UserUncheckedCreateWithoutUser_lambdaInput>
  }

  export type UserUpsertWithoutUser_lambdaInput = {
    update: XOR<UserUpdateWithoutUser_lambdaInput, UserUncheckedUpdateWithoutUser_lambdaInput>
    create: XOR<UserCreateWithoutUser_lambdaInput, UserUncheckedCreateWithoutUser_lambdaInput>
  }

  export type UserUpdateWithoutUser_lambdaInput = {
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    Numero_rue?: NullableStringFieldUpdateOperationsInput | string | null
    code_postale?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: IntFieldUpdateOperationsInput | number
    role?: RoleUpdateOneWithoutUserNestedInput
    botanistes?: BotanisteUpdateManyWithoutId_userNestedInput
    annonces?: AnnonceUpdateManyWithoutUserNestedInput
    gardiennages?: GardiennageUpdateManyWithoutUserNestedInput
    Conseil?: ConseilUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_lambdaInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    Numero_rue?: NullableStringFieldUpdateOperationsInput | string | null
    code_postale?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: IntFieldUpdateOperationsInput | number
    role?: RoleUncheckedUpdateOneWithoutUserNestedInput
    botanistes?: BotanisteUncheckedUpdateManyWithoutId_userNestedInput
    annonces?: AnnonceUncheckedUpdateManyWithoutUserNestedInput
    gardiennages?: GardiennageUncheckedUpdateManyWithoutUserNestedInput
    Conseil?: ConseilUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAnnoncesInput = {
    prenom?: string | null
    nom: string
    email: string
    telephone: string
    Numero_rue?: string | null
    code_postale?: string | null
    ville?: string | null
    mdp?: string | null
    flag?: number
    role?: RoleCreateNestedOneWithoutUserInput
    botanistes?: BotanisteCreateNestedManyWithoutId_userInput
    user_lambda?: User_lambdaCreateNestedManyWithoutId_userInput
    gardiennages?: GardiennageCreateNestedManyWithoutUserInput
    Conseil?: ConseilCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnnoncesInput = {
    id_user?: number
    prenom?: string | null
    nom: string
    email: string
    telephone: string
    Numero_rue?: string | null
    code_postale?: string | null
    ville?: string | null
    mdp?: string | null
    flag?: number
    role?: RoleUncheckedCreateNestedOneWithoutUserInput
    botanistes?: BotanisteUncheckedCreateNestedManyWithoutId_userInput
    user_lambda?: User_lambdaUncheckedCreateNestedManyWithoutId_userInput
    gardiennages?: GardiennageUncheckedCreateNestedManyWithoutUserInput
    Conseil?: ConseilUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnnoncesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnnoncesInput, UserUncheckedCreateWithoutAnnoncesInput>
  }

  export type GardiennageCreateWithoutAnnonceInput = {
    date_debut: Date | string
    date_fin: Date | string
    description?: string | null
    user: UserCreateNestedOneWithoutGardiennagesInput
    photo_gardiennage?: PhotoGardiennageCreateNestedManyWithoutGardiennageInput
  }

  export type GardiennageUncheckedCreateWithoutAnnonceInput = {
    id_gardiennage?: number
    date_debut: Date | string
    date_fin: Date | string
    description?: string | null
    id_user: number
    photo_gardiennage?: PhotoGardiennageUncheckedCreateNestedManyWithoutGardiennageInput
  }

  export type GardiennageCreateOrConnectWithoutAnnonceInput = {
    where: GardiennageWhereUniqueInput
    create: XOR<GardiennageCreateWithoutAnnonceInput, GardiennageUncheckedCreateWithoutAnnonceInput>
  }

  export type PhotoAnnonceCreateWithoutAnnonceInput = {
    lien: string
    date_photo: Date | string
  }

  export type PhotoAnnonceUncheckedCreateWithoutAnnonceInput = {
    id_photo?: number
    lien: string
    date_photo: Date | string
  }

  export type PhotoAnnonceCreateOrConnectWithoutAnnonceInput = {
    where: PhotoAnnonceWhereUniqueInput
    create: XOR<PhotoAnnonceCreateWithoutAnnonceInput, PhotoAnnonceUncheckedCreateWithoutAnnonceInput>
  }

  export type UserUpsertWithoutAnnoncesInput = {
    update: XOR<UserUpdateWithoutAnnoncesInput, UserUncheckedUpdateWithoutAnnoncesInput>
    create: XOR<UserCreateWithoutAnnoncesInput, UserUncheckedCreateWithoutAnnoncesInput>
  }

  export type UserUpdateWithoutAnnoncesInput = {
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    Numero_rue?: NullableStringFieldUpdateOperationsInput | string | null
    code_postale?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: IntFieldUpdateOperationsInput | number
    role?: RoleUpdateOneWithoutUserNestedInput
    botanistes?: BotanisteUpdateManyWithoutId_userNestedInput
    user_lambda?: User_lambdaUpdateManyWithoutId_userNestedInput
    gardiennages?: GardiennageUpdateManyWithoutUserNestedInput
    Conseil?: ConseilUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnnoncesInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    Numero_rue?: NullableStringFieldUpdateOperationsInput | string | null
    code_postale?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: IntFieldUpdateOperationsInput | number
    role?: RoleUncheckedUpdateOneWithoutUserNestedInput
    botanistes?: BotanisteUncheckedUpdateManyWithoutId_userNestedInput
    user_lambda?: User_lambdaUncheckedUpdateManyWithoutId_userNestedInput
    gardiennages?: GardiennageUncheckedUpdateManyWithoutUserNestedInput
    Conseil?: ConseilUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GardiennageUpsertWithoutAnnonceInput = {
    update: XOR<GardiennageUpdateWithoutAnnonceInput, GardiennageUncheckedUpdateWithoutAnnonceInput>
    create: XOR<GardiennageCreateWithoutAnnonceInput, GardiennageUncheckedCreateWithoutAnnonceInput>
  }

  export type GardiennageUpdateWithoutAnnonceInput = {
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutGardiennagesNestedInput
    photo_gardiennage?: PhotoGardiennageUpdateManyWithoutGardiennageNestedInput
  }

  export type GardiennageUncheckedUpdateWithoutAnnonceInput = {
    id_gardiennage?: IntFieldUpdateOperationsInput | number
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    id_user?: IntFieldUpdateOperationsInput | number
    photo_gardiennage?: PhotoGardiennageUncheckedUpdateManyWithoutGardiennageNestedInput
  }

  export type PhotoAnnonceUpsertWithWhereUniqueWithoutAnnonceInput = {
    where: PhotoAnnonceWhereUniqueInput
    update: XOR<PhotoAnnonceUpdateWithoutAnnonceInput, PhotoAnnonceUncheckedUpdateWithoutAnnonceInput>
    create: XOR<PhotoAnnonceCreateWithoutAnnonceInput, PhotoAnnonceUncheckedCreateWithoutAnnonceInput>
  }

  export type PhotoAnnonceUpdateWithWhereUniqueWithoutAnnonceInput = {
    where: PhotoAnnonceWhereUniqueInput
    data: XOR<PhotoAnnonceUpdateWithoutAnnonceInput, PhotoAnnonceUncheckedUpdateWithoutAnnonceInput>
  }

  export type PhotoAnnonceUpdateManyWithWhereWithoutAnnonceInput = {
    where: PhotoAnnonceScalarWhereInput
    data: XOR<PhotoAnnonceUpdateManyMutationInput, PhotoAnnonceUncheckedUpdateManyWithoutPhotoInput>
  }

  export type PhotoAnnonceScalarWhereInput = {
    AND?: Enumerable<PhotoAnnonceScalarWhereInput>
    OR?: Enumerable<PhotoAnnonceScalarWhereInput>
    NOT?: Enumerable<PhotoAnnonceScalarWhereInput>
    id_photo?: IntFilter | number
    lien?: StringFilter | string
    date_photo?: DateTimeFilter | Date | string
    idAnnonce?: IntFilter | number
  }

  export type UserCreateWithoutGardiennagesInput = {
    prenom?: string | null
    nom: string
    email: string
    telephone: string
    Numero_rue?: string | null
    code_postale?: string | null
    ville?: string | null
    mdp?: string | null
    flag?: number
    role?: RoleCreateNestedOneWithoutUserInput
    botanistes?: BotanisteCreateNestedManyWithoutId_userInput
    user_lambda?: User_lambdaCreateNestedManyWithoutId_userInput
    annonces?: AnnonceCreateNestedManyWithoutUserInput
    Conseil?: ConseilCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGardiennagesInput = {
    id_user?: number
    prenom?: string | null
    nom: string
    email: string
    telephone: string
    Numero_rue?: string | null
    code_postale?: string | null
    ville?: string | null
    mdp?: string | null
    flag?: number
    role?: RoleUncheckedCreateNestedOneWithoutUserInput
    botanistes?: BotanisteUncheckedCreateNestedManyWithoutId_userInput
    user_lambda?: User_lambdaUncheckedCreateNestedManyWithoutId_userInput
    annonces?: AnnonceUncheckedCreateNestedManyWithoutUserInput
    Conseil?: ConseilUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGardiennagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGardiennagesInput, UserUncheckedCreateWithoutGardiennagesInput>
  }

  export type AnnonceCreateWithoutGardiennageInput = {
    localisation?: string | null
    description?: string | null
    type_gardien?: number | null
    nb_signalement?: number
    latidute: number
    longitude: number
    user: UserCreateNestedOneWithoutAnnoncesInput
    photo?: PhotoAnnonceCreateNestedManyWithoutAnnonceInput
  }

  export type AnnonceUncheckedCreateWithoutGardiennageInput = {
    id_annonce?: number
    localisation?: string | null
    description?: string | null
    type_gardien?: number | null
    nb_signalement?: number
    latidute: number
    longitude: number
    id_user: number
    photo?: PhotoAnnonceUncheckedCreateNestedManyWithoutAnnonceInput
  }

  export type AnnonceCreateOrConnectWithoutGardiennageInput = {
    where: AnnonceWhereUniqueInput
    create: XOR<AnnonceCreateWithoutGardiennageInput, AnnonceUncheckedCreateWithoutGardiennageInput>
  }

  export type PhotoGardiennageCreateWithoutGardiennageInput = {
    lien: string
    date_photo: Date | string
  }

  export type PhotoGardiennageUncheckedCreateWithoutGardiennageInput = {
    id_photo?: number
    lien: string
    date_photo: Date | string
  }

  export type PhotoGardiennageCreateOrConnectWithoutGardiennageInput = {
    where: PhotoGardiennageWhereUniqueInput
    create: XOR<PhotoGardiennageCreateWithoutGardiennageInput, PhotoGardiennageUncheckedCreateWithoutGardiennageInput>
  }

  export type UserUpsertWithoutGardiennagesInput = {
    update: XOR<UserUpdateWithoutGardiennagesInput, UserUncheckedUpdateWithoutGardiennagesInput>
    create: XOR<UserCreateWithoutGardiennagesInput, UserUncheckedCreateWithoutGardiennagesInput>
  }

  export type UserUpdateWithoutGardiennagesInput = {
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    Numero_rue?: NullableStringFieldUpdateOperationsInput | string | null
    code_postale?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: IntFieldUpdateOperationsInput | number
    role?: RoleUpdateOneWithoutUserNestedInput
    botanistes?: BotanisteUpdateManyWithoutId_userNestedInput
    user_lambda?: User_lambdaUpdateManyWithoutId_userNestedInput
    annonces?: AnnonceUpdateManyWithoutUserNestedInput
    Conseil?: ConseilUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGardiennagesInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    Numero_rue?: NullableStringFieldUpdateOperationsInput | string | null
    code_postale?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: IntFieldUpdateOperationsInput | number
    role?: RoleUncheckedUpdateOneWithoutUserNestedInput
    botanistes?: BotanisteUncheckedUpdateManyWithoutId_userNestedInput
    user_lambda?: User_lambdaUncheckedUpdateManyWithoutId_userNestedInput
    annonces?: AnnonceUncheckedUpdateManyWithoutUserNestedInput
    Conseil?: ConseilUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AnnonceUpsertWithoutGardiennageInput = {
    update: XOR<AnnonceUpdateWithoutGardiennageInput, AnnonceUncheckedUpdateWithoutGardiennageInput>
    create: XOR<AnnonceCreateWithoutGardiennageInput, AnnonceUncheckedCreateWithoutGardiennageInput>
  }

  export type AnnonceUpdateWithoutGardiennageInput = {
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_gardien?: NullableIntFieldUpdateOperationsInput | number | null
    nb_signalement?: IntFieldUpdateOperationsInput | number
    latidute?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutAnnoncesNestedInput
    photo?: PhotoAnnonceUpdateManyWithoutAnnonceNestedInput
  }

  export type AnnonceUncheckedUpdateWithoutGardiennageInput = {
    id_annonce?: IntFieldUpdateOperationsInput | number
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_gardien?: NullableIntFieldUpdateOperationsInput | number | null
    nb_signalement?: IntFieldUpdateOperationsInput | number
    latidute?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    photo?: PhotoAnnonceUncheckedUpdateManyWithoutAnnonceNestedInput
  }

  export type PhotoGardiennageUpsertWithWhereUniqueWithoutGardiennageInput = {
    where: PhotoGardiennageWhereUniqueInput
    update: XOR<PhotoGardiennageUpdateWithoutGardiennageInput, PhotoGardiennageUncheckedUpdateWithoutGardiennageInput>
    create: XOR<PhotoGardiennageCreateWithoutGardiennageInput, PhotoGardiennageUncheckedCreateWithoutGardiennageInput>
  }

  export type PhotoGardiennageUpdateWithWhereUniqueWithoutGardiennageInput = {
    where: PhotoGardiennageWhereUniqueInput
    data: XOR<PhotoGardiennageUpdateWithoutGardiennageInput, PhotoGardiennageUncheckedUpdateWithoutGardiennageInput>
  }

  export type PhotoGardiennageUpdateManyWithWhereWithoutGardiennageInput = {
    where: PhotoGardiennageScalarWhereInput
    data: XOR<PhotoGardiennageUpdateManyMutationInput, PhotoGardiennageUncheckedUpdateManyWithoutPhoto_gardiennageInput>
  }

  export type PhotoGardiennageScalarWhereInput = {
    AND?: Enumerable<PhotoGardiennageScalarWhereInput>
    OR?: Enumerable<PhotoGardiennageScalarWhereInput>
    NOT?: Enumerable<PhotoGardiennageScalarWhereInput>
    id_photo?: IntFilter | number
    lien?: StringFilter | string
    date_photo?: DateTimeFilter | Date | string
    idGardiennage?: IntFilter | number
  }

  export type GardiennageCreateWithoutPhoto_gardiennageInput = {
    date_debut: Date | string
    date_fin: Date | string
    description?: string | null
    user: UserCreateNestedOneWithoutGardiennagesInput
    annonce: AnnonceCreateNestedOneWithoutGardiennageInput
  }

  export type GardiennageUncheckedCreateWithoutPhoto_gardiennageInput = {
    id_gardiennage?: number
    date_debut: Date | string
    date_fin: Date | string
    description?: string | null
    id_user: number
    idAnnonce: number
  }

  export type GardiennageCreateOrConnectWithoutPhoto_gardiennageInput = {
    where: GardiennageWhereUniqueInput
    create: XOR<GardiennageCreateWithoutPhoto_gardiennageInput, GardiennageUncheckedCreateWithoutPhoto_gardiennageInput>
  }

  export type GardiennageUpsertWithoutPhoto_gardiennageInput = {
    update: XOR<GardiennageUpdateWithoutPhoto_gardiennageInput, GardiennageUncheckedUpdateWithoutPhoto_gardiennageInput>
    create: XOR<GardiennageCreateWithoutPhoto_gardiennageInput, GardiennageUncheckedCreateWithoutPhoto_gardiennageInput>
  }

  export type GardiennageUpdateWithoutPhoto_gardiennageInput = {
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutGardiennagesNestedInput
    annonce?: AnnonceUpdateOneRequiredWithoutGardiennageNestedInput
  }

  export type GardiennageUncheckedUpdateWithoutPhoto_gardiennageInput = {
    id_gardiennage?: IntFieldUpdateOperationsInput | number
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    id_user?: IntFieldUpdateOperationsInput | number
    idAnnonce?: IntFieldUpdateOperationsInput | number
  }

  export type AnnonceCreateWithoutPhotoInput = {
    localisation?: string | null
    description?: string | null
    type_gardien?: number | null
    nb_signalement?: number
    latidute: number
    longitude: number
    user: UserCreateNestedOneWithoutAnnoncesInput
    gardiennage?: GardiennageCreateNestedOneWithoutAnnonceInput
  }

  export type AnnonceUncheckedCreateWithoutPhotoInput = {
    id_annonce?: number
    localisation?: string | null
    description?: string | null
    type_gardien?: number | null
    nb_signalement?: number
    latidute: number
    longitude: number
    id_user: number
    gardiennage?: GardiennageUncheckedCreateNestedOneWithoutAnnonceInput
  }

  export type AnnonceCreateOrConnectWithoutPhotoInput = {
    where: AnnonceWhereUniqueInput
    create: XOR<AnnonceCreateWithoutPhotoInput, AnnonceUncheckedCreateWithoutPhotoInput>
  }

  export type AnnonceUpsertWithoutPhotoInput = {
    update: XOR<AnnonceUpdateWithoutPhotoInput, AnnonceUncheckedUpdateWithoutPhotoInput>
    create: XOR<AnnonceCreateWithoutPhotoInput, AnnonceUncheckedCreateWithoutPhotoInput>
  }

  export type AnnonceUpdateWithoutPhotoInput = {
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_gardien?: NullableIntFieldUpdateOperationsInput | number | null
    nb_signalement?: IntFieldUpdateOperationsInput | number
    latidute?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutAnnoncesNestedInput
    gardiennage?: GardiennageUpdateOneWithoutAnnonceNestedInput
  }

  export type AnnonceUncheckedUpdateWithoutPhotoInput = {
    id_annonce?: IntFieldUpdateOperationsInput | number
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_gardien?: NullableIntFieldUpdateOperationsInput | number | null
    nb_signalement?: IntFieldUpdateOperationsInput | number
    latidute?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    id_user?: IntFieldUpdateOperationsInput | number
    gardiennage?: GardiennageUncheckedUpdateOneWithoutAnnonceNestedInput
  }

  export type UserCreateWithoutConseilInput = {
    prenom?: string | null
    nom: string
    email: string
    telephone: string
    Numero_rue?: string | null
    code_postale?: string | null
    ville?: string | null
    mdp?: string | null
    flag?: number
    role?: RoleCreateNestedOneWithoutUserInput
    botanistes?: BotanisteCreateNestedManyWithoutId_userInput
    user_lambda?: User_lambdaCreateNestedManyWithoutId_userInput
    annonces?: AnnonceCreateNestedManyWithoutUserInput
    gardiennages?: GardiennageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConseilInput = {
    id_user?: number
    prenom?: string | null
    nom: string
    email: string
    telephone: string
    Numero_rue?: string | null
    code_postale?: string | null
    ville?: string | null
    mdp?: string | null
    flag?: number
    role?: RoleUncheckedCreateNestedOneWithoutUserInput
    botanistes?: BotanisteUncheckedCreateNestedManyWithoutId_userInput
    user_lambda?: User_lambdaUncheckedCreateNestedManyWithoutId_userInput
    annonces?: AnnonceUncheckedCreateNestedManyWithoutUserInput
    gardiennages?: GardiennageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConseilInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConseilInput, UserUncheckedCreateWithoutConseilInput>
  }

  export type UserUpsertWithoutConseilInput = {
    update: XOR<UserUpdateWithoutConseilInput, UserUncheckedUpdateWithoutConseilInput>
    create: XOR<UserCreateWithoutConseilInput, UserUncheckedCreateWithoutConseilInput>
  }

  export type UserUpdateWithoutConseilInput = {
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    Numero_rue?: NullableStringFieldUpdateOperationsInput | string | null
    code_postale?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: IntFieldUpdateOperationsInput | number
    role?: RoleUpdateOneWithoutUserNestedInput
    botanistes?: BotanisteUpdateManyWithoutId_userNestedInput
    user_lambda?: User_lambdaUpdateManyWithoutId_userNestedInput
    annonces?: AnnonceUpdateManyWithoutUserNestedInput
    gardiennages?: GardiennageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConseilInput = {
    id_user?: IntFieldUpdateOperationsInput | number
    prenom?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    Numero_rue?: NullableStringFieldUpdateOperationsInput | string | null
    code_postale?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    mdp?: NullableStringFieldUpdateOperationsInput | string | null
    flag?: IntFieldUpdateOperationsInput | number
    role?: RoleUncheckedUpdateOneWithoutUserNestedInput
    botanistes?: BotanisteUncheckedUpdateManyWithoutId_userNestedInput
    user_lambda?: User_lambdaUncheckedUpdateManyWithoutId_userNestedInput
    annonces?: AnnonceUncheckedUpdateManyWithoutUserNestedInput
    gardiennages?: GardiennageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BotanisteUpdateWithoutId_userInput = {

  }

  export type BotanisteUncheckedUpdateWithoutId_userInput = {

  }

  export type BotanisteUncheckedUpdateManyWithoutBotanistesInput = {

  }

  export type User_lambdaUpdateWithoutId_userInput = {

  }

  export type User_lambdaUncheckedUpdateWithoutId_userInput = {

  }

  export type User_lambdaUncheckedUpdateManyWithoutUser_lambdaInput = {

  }

  export type AnnonceUpdateWithoutUserInput = {
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_gardien?: NullableIntFieldUpdateOperationsInput | number | null
    nb_signalement?: IntFieldUpdateOperationsInput | number
    latidute?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    gardiennage?: GardiennageUpdateOneWithoutAnnonceNestedInput
    photo?: PhotoAnnonceUpdateManyWithoutAnnonceNestedInput
  }

  export type AnnonceUncheckedUpdateWithoutUserInput = {
    id_annonce?: IntFieldUpdateOperationsInput | number
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_gardien?: NullableIntFieldUpdateOperationsInput | number | null
    nb_signalement?: IntFieldUpdateOperationsInput | number
    latidute?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    gardiennage?: GardiennageUncheckedUpdateOneWithoutAnnonceNestedInput
    photo?: PhotoAnnonceUncheckedUpdateManyWithoutAnnonceNestedInput
  }

  export type AnnonceUncheckedUpdateManyWithoutAnnoncesInput = {
    id_annonce?: IntFieldUpdateOperationsInput | number
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type_gardien?: NullableIntFieldUpdateOperationsInput | number | null
    nb_signalement?: IntFieldUpdateOperationsInput | number
    latidute?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type GardiennageUpdateWithoutUserInput = {
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    annonce?: AnnonceUpdateOneRequiredWithoutGardiennageNestedInput
    photo_gardiennage?: PhotoGardiennageUpdateManyWithoutGardiennageNestedInput
  }

  export type GardiennageUncheckedUpdateWithoutUserInput = {
    id_gardiennage?: IntFieldUpdateOperationsInput | number
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    idAnnonce?: IntFieldUpdateOperationsInput | number
    photo_gardiennage?: PhotoGardiennageUncheckedUpdateManyWithoutGardiennageNestedInput
  }

  export type GardiennageUncheckedUpdateManyWithoutGardiennagesInput = {
    id_gardiennage?: IntFieldUpdateOperationsInput | number
    date_debut?: DateTimeFieldUpdateOperationsInput | Date | string
    date_fin?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    idAnnonce?: IntFieldUpdateOperationsInput | number
  }

  export type ConseilUpdateWithoutUserInput = {
    date_conseil?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type ConseilUncheckedUpdateWithoutUserInput = {
    id_consiel?: IntFieldUpdateOperationsInput | number
    date_conseil?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type ConseilUncheckedUpdateManyWithoutConseilInput = {
    id_consiel?: IntFieldUpdateOperationsInput | number
    date_conseil?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type PhotoAnnonceUpdateWithoutAnnonceInput = {
    lien?: StringFieldUpdateOperationsInput | string
    date_photo?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoAnnonceUncheckedUpdateWithoutAnnonceInput = {
    id_photo?: IntFieldUpdateOperationsInput | number
    lien?: StringFieldUpdateOperationsInput | string
    date_photo?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoAnnonceUncheckedUpdateManyWithoutPhotoInput = {
    id_photo?: IntFieldUpdateOperationsInput | number
    lien?: StringFieldUpdateOperationsInput | string
    date_photo?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoGardiennageUpdateWithoutGardiennageInput = {
    lien?: StringFieldUpdateOperationsInput | string
    date_photo?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoGardiennageUncheckedUpdateWithoutGardiennageInput = {
    id_photo?: IntFieldUpdateOperationsInput | number
    lien?: StringFieldUpdateOperationsInput | string
    date_photo?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoGardiennageUncheckedUpdateManyWithoutPhoto_gardiennageInput = {
    id_photo?: IntFieldUpdateOperationsInput | number
    lien?: StringFieldUpdateOperationsInput | string
    date_photo?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}