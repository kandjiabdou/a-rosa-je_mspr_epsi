{"ast":null,"code":"import { createVNode as _createVNode } from \"vue\";\n// Styles\nimport \"./VSlideGroup.css\";\n\n// Components\nimport { VFadeTransition } from \"../transitions/index.mjs\";\nimport { VIcon } from \"../VIcon/index.mjs\"; // Composables\nimport { IconValue } from \"../../composables/icons.mjs\";\nimport { makeGroupProps, useGroup } from \"../../composables/group.mjs\";\nimport { makeTagProps } from \"../../composables/tag.mjs\";\nimport { useDisplay } from \"../../composables/index.mjs\";\nimport { useResizeObserver } from \"../../composables/resizeObserver.mjs\";\nimport { useRtl } from \"../../composables/locale.mjs\"; // Utilities\nimport { computed, ref, watch } from 'vue';\nimport { clamp, genericComponent, IN_BROWSER, useRender } from \"../../util/index.mjs\";\nimport { bias, calculateCenteredOffset, calculateUpdatedOffset } from \"./helpers.mjs\"; // Types\nexport const VSlideGroupSymbol = Symbol.for('vuetify:v-slide-group');\nexport const VSlideGroup = genericComponent()({\n  name: 'VSlideGroup',\n  props: {\n    centerActive: Boolean,\n    direction: {\n      type: String,\n      default: 'horizontal'\n    },\n    symbol: {\n      type: null,\n      default: VSlideGroupSymbol\n    },\n    nextIcon: {\n      type: IconValue,\n      default: '$next'\n    },\n    prevIcon: {\n      type: IconValue,\n      default: '$prev'\n    },\n    showArrows: {\n      type: [Boolean, String],\n      validator: v => typeof v === 'boolean' || ['always', 'desktop', 'mobile'].includes(v)\n    },\n    ...makeTagProps(),\n    ...makeGroupProps({\n      selectedClass: 'v-slide-group-item--active'\n    })\n  },\n  emits: {\n    'update:modelValue': value => true\n  },\n  setup(props, _ref) {\n    let {\n      slots\n    } = _ref;\n    const {\n      isRtl\n    } = useRtl();\n    const {\n      mobile\n    } = useDisplay();\n    const group = useGroup(props, props.symbol);\n    const isOverflowing = ref(false);\n    const scrollOffset = ref(0);\n    const containerSize = ref(0);\n    const contentSize = ref(0);\n    const isHorizontal = computed(() => props.direction === 'horizontal');\n    const {\n      resizeRef: containerRef,\n      contentRect: containerRect\n    } = useResizeObserver();\n    const {\n      resizeRef: contentRef,\n      contentRect\n    } = useResizeObserver();\n    const firstSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1;\n      return group.items.value.findIndex(item => item.id === group.selected.value[0]);\n    });\n    const lastSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1;\n      return group.items.value.findIndex(item => item.id === group.selected.value[group.selected.value.length - 1]);\n    });\n    if (IN_BROWSER) {\n      let frame = -1;\n      watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {\n        cancelAnimationFrame(frame);\n        frame = requestAnimationFrame(() => {\n          if (containerRect.value && contentRect.value) {\n            const sizeProperty = isHorizontal.value ? 'width' : 'height';\n            containerSize.value = containerRect.value[sizeProperty];\n            contentSize.value = contentRect.value[sizeProperty];\n            isOverflowing.value = containerSize.value + 1 < contentSize.value;\n          }\n          if (firstSelectedIndex.value >= 0 && contentRef.value) {\n            // TODO: Is this too naive? Should we store element references in group composable?\n            const selectedElement = contentRef.value.children[lastSelectedIndex.value];\n            if (firstSelectedIndex.value === 0 || !isOverflowing.value) {\n              scrollOffset.value = 0;\n            } else if (props.centerActive) {\n              scrollOffset.value = calculateCenteredOffset({\n                selectedElement,\n                containerSize: containerSize.value,\n                contentSize: contentSize.value,\n                isRtl: isRtl.value,\n                isHorizontal: isHorizontal.value\n              });\n            } else if (isOverflowing.value) {\n              scrollOffset.value = calculateUpdatedOffset({\n                selectedElement,\n                containerSize: containerSize.value,\n                contentSize: contentSize.value,\n                isRtl: isRtl.value,\n                currentScrollOffset: scrollOffset.value,\n                isHorizontal: isHorizontal.value\n              });\n            }\n          }\n        });\n      });\n    }\n    const disableTransition = ref(false);\n    let startTouch = 0;\n    let startOffset = 0;\n    function onTouchstart(e) {\n      const sizeProperty = isHorizontal.value ? 'clientX' : 'clientY';\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1;\n      startOffset = sign * scrollOffset.value;\n      startTouch = e.touches[0][sizeProperty];\n      disableTransition.value = true;\n    }\n    function onTouchmove(e) {\n      if (!isOverflowing.value) return;\n      const sizeProperty = isHorizontal.value ? 'clientX' : 'clientY';\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1;\n      scrollOffset.value = sign * (startOffset + startTouch - e.touches[0][sizeProperty]);\n    }\n    function onTouchend(e) {\n      const maxScrollOffset = contentSize.value - containerSize.value;\n      if (scrollOffset.value < 0 || !isOverflowing.value) {\n        scrollOffset.value = 0;\n      } else if (scrollOffset.value >= maxScrollOffset) {\n        scrollOffset.value = maxScrollOffset;\n      }\n      disableTransition.value = false;\n    }\n    function onScroll() {\n      if (!containerRef.value) return;\n      containerRef.value[isHorizontal.value ? 'scrollLeft' : 'scrollTop'] = 0;\n    }\n    const isFocused = ref(false);\n    function onFocusin(e) {\n      isFocused.value = true;\n      if (!isOverflowing.value || !contentRef.value) return;\n\n      // Focused element is likely to be the root of an item, so a\n      // breadth-first search will probably find it in the first iteration\n      for (const el of e.composedPath()) {\n        for (const item of contentRef.value.children) {\n          if (item === el) {\n            scrollOffset.value = calculateUpdatedOffset({\n              selectedElement: item,\n              containerSize: containerSize.value,\n              contentSize: contentSize.value,\n              isRtl: isRtl.value,\n              currentScrollOffset: scrollOffset.value,\n              isHorizontal: isHorizontal.value\n            });\n            return;\n          }\n        }\n      }\n    }\n    function onFocusout(e) {\n      isFocused.value = false;\n    }\n    function onFocus(e) {\n      var _contentRef$value;\n      if (!isFocused.value && !(e.relatedTarget && (_contentRef$value = contentRef.value) != null && _contentRef$value.contains(e.relatedTarget))) focus();\n    }\n    function onKeydown(e) {\n      if (!contentRef.value) return;\n      if (isHorizontal.value) {\n        if (e.key === 'ArrowRight') {\n          focus(isRtl.value ? 'prev' : 'next');\n        } else if (e.key === 'ArrowLeft') {\n          focus(isRtl.value ? 'next' : 'prev');\n        }\n      } else {\n        if (e.key === 'ArrowDown') {\n          focus('next');\n        } else if (e.key === 'ArrowUp') {\n          focus('prev');\n        }\n      }\n      if (e.key === 'Home') {\n        focus('first');\n      } else if (e.key === 'End') {\n        focus('last');\n      }\n    }\n    function focus(location) {\n      if (!contentRef.value) return;\n      if (!location) {\n        var _focusable$;\n        const focusable = [...contentRef.value.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])')].filter(el => !el.hasAttribute('disabled'));\n        (_focusable$ = focusable[0]) == null ? void 0 : _focusable$.focus();\n      } else if (location === 'next') {\n        var _contentRef$value$que;\n        const el = (_contentRef$value$que = contentRef.value.querySelector(':focus')) == null ? void 0 : _contentRef$value$que.nextElementSibling;\n        if (el) el.focus();else focus('first');\n      } else if (location === 'prev') {\n        var _contentRef$value$que2;\n        const el = (_contentRef$value$que2 = contentRef.value.querySelector(':focus')) == null ? void 0 : _contentRef$value$que2.previousElementSibling;\n        if (el) el.focus();else focus('last');\n      } else if (location === 'first') {\n        var _contentRef$value$fir;\n        (_contentRef$value$fir = contentRef.value.firstElementChild) == null ? void 0 : _contentRef$value$fir.focus();\n      } else if (location === 'last') {\n        var _contentRef$value$las;\n        (_contentRef$value$las = contentRef.value.lastElementChild) == null ? void 0 : _contentRef$value$las.focus();\n      }\n    }\n    function scrollTo(location) {\n      const newAbsoluteOffset = scrollOffset.value + (location === 'prev' ? -1 : 1) * containerSize.value;\n      scrollOffset.value = clamp(newAbsoluteOffset, 0, contentSize.value - containerSize.value);\n    }\n    const contentStyles = computed(() => {\n      // This adds friction when scrolling the 'wrong' way when at max offset\n      let scrollAmount = scrollOffset.value > contentSize.value - containerSize.value ? -(contentSize.value - containerSize.value) + bias(contentSize.value - containerSize.value - scrollOffset.value) : -scrollOffset.value;\n\n      // This adds friction when scrolling the 'wrong' way when at min offset\n      if (scrollOffset.value <= 0) {\n        scrollAmount = bias(-scrollOffset.value);\n      }\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1;\n      return {\n        transform: `translate${isHorizontal.value ? 'X' : 'Y'}(${sign * scrollAmount}px)`,\n        transition: disableTransition.value ? 'none' : '',\n        willChange: disableTransition.value ? 'transform' : ''\n      };\n    });\n    const slotProps = computed(() => ({\n      next: group.next,\n      prev: group.prev,\n      select: group.select,\n      isSelected: group.isSelected\n    }));\n    const hasAffixes = computed(() => {\n      switch (props.showArrows) {\n        // Always show arrows on desktop & mobile\n        case 'always':\n          return true;\n\n        // Always show arrows on desktop\n        case 'desktop':\n          return !mobile.value;\n\n        // Show arrows on mobile when overflowing.\n        // This matches the default 2.2 behavior\n        case true:\n          return isOverflowing.value || Math.abs(scrollOffset.value) > 0;\n\n        // Always show on mobile\n        case 'mobile':\n          return mobile.value || isOverflowing.value || Math.abs(scrollOffset.value) > 0;\n\n        // https://material.io/components/tabs#scrollable-tabs\n        // Always show arrows when\n        // overflowed on desktop\n        default:\n          return !mobile.value && (isOverflowing.value || Math.abs(scrollOffset.value) > 0);\n      }\n    });\n    const hasPrev = computed(() => {\n      return Math.abs(scrollOffset.value) > 0;\n    });\n    const hasNext = computed(() => {\n      // Check one scroll ahead to know the width of right-most item\n      return contentSize.value > Math.abs(scrollOffset.value) + containerSize.value;\n    });\n    useRender(() => {\n      var _slots$prev, _slots$default, _slots$next;\n      return _createVNode(props.tag, {\n        \"class\": ['v-slide-group', {\n          'v-slide-group--vertical': !isHorizontal.value,\n          'v-slide-group--has-affixes': hasAffixes.value,\n          'v-slide-group--is-overflowing': isOverflowing.value\n        }],\n        \"tabindex\": isFocused.value || group.selected.value.length ? -1 : 0,\n        \"onFocus\": onFocus\n      }, {\n        default: () => [hasAffixes.value && _createVNode(\"div\", {\n          \"key\": \"prev\",\n          \"class\": ['v-slide-group__prev', {\n            'v-slide-group__prev--disabled': !hasPrev.value\n          }],\n          \"onClick\": () => scrollTo('prev')\n        }, [((_slots$prev = slots.prev) == null ? void 0 : _slots$prev.call(slots, slotProps.value)) ?? _createVNode(VFadeTransition, null, {\n          default: () => [_createVNode(VIcon, {\n            \"icon\": isRtl.value ? props.nextIcon : props.prevIcon\n          }, null)]\n        })]), _createVNode(\"div\", {\n          \"key\": \"container\",\n          \"ref\": containerRef,\n          \"class\": \"v-slide-group__container\",\n          \"onScroll\": onScroll\n        }, [_createVNode(\"div\", {\n          \"ref\": contentRef,\n          \"class\": \"v-slide-group__content\",\n          \"style\": contentStyles.value,\n          \"onTouchstartPassive\": onTouchstart,\n          \"onTouchmovePassive\": onTouchmove,\n          \"onTouchendPassive\": onTouchend,\n          \"onFocusin\": onFocusin,\n          \"onFocusout\": onFocusout,\n          \"onKeydown\": onKeydown\n        }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, slotProps.value)])]), hasAffixes.value && _createVNode(\"div\", {\n          \"key\": \"next\",\n          \"class\": ['v-slide-group__next', {\n            'v-slide-group__next--disabled': !hasNext.value\n          }],\n          \"onClick\": () => scrollTo('next')\n        }, [((_slots$next = slots.next) == null ? void 0 : _slots$next.call(slots, slotProps.value)) ?? _createVNode(VFadeTransition, null, {\n          default: () => [_createVNode(VIcon, {\n            \"icon\": isRtl.value ? props.prevIcon : props.nextIcon\n          }, null)]\n        })])]\n      });\n    });\n    return {\n      selected: group.selected,\n      scrollTo,\n      scrollOffset,\n      focus\n    };\n  }\n});","map":{"version":3,"mappings":"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","names":["VFadeTransition","VIcon","IconValue","makeGroupProps","useGroup","makeTagProps","useDisplay","useResizeObserver","useRtl","computed","ref","watch","clamp","genericComponent","IN_BROWSER","useRender","bias","calculateCenteredOffset","calculateUpdatedOffset","VSlideGroupSymbol","Symbol","for","VSlideGroup","name","props","centerActive","Boolean","direction","type","String","default","symbol","nextIcon","prevIcon","showArrows","validator","v","includes","selectedClass","emits","value","setup","slots","isRtl","mobile","group","isOverflowing","scrollOffset","containerSize","contentSize","isHorizontal","resizeRef","containerRef","contentRect","containerRect","contentRef","firstSelectedIndex","selected","length","items","findIndex","item","id","lastSelectedIndex","frame","cancelAnimationFrame","requestAnimationFrame","sizeProperty","selectedElement","children","currentScrollOffset","disableTransition","startTouch","startOffset","onTouchstart","e","sign","touches","onTouchmove","onTouchend","maxScrollOffset","onScroll","isFocused","onFocusin","el","composedPath","onFocusout","onFocus","relatedTarget","_contentRef$value","contains","focus","onKeydown","key","location","focusable","querySelectorAll","filter","hasAttribute","_focusable$","querySelector","_contentRef$value$que","nextElementSibling","_contentRef$value$que2","previousElementSibling","firstElementChild","_contentRef$value$fir","lastElementChild","_contentRef$value$las","scrollTo","newAbsoluteOffset","contentStyles","scrollAmount","transform","transition","willChange","slotProps","next","prev","select","isSelected","hasAffixes","Math","abs","hasPrev","hasNext","_slots$prev","_slots$default","_slots$next"],"sources":["../../../src/components/VSlideGroup/VSlideGroup.tsx"],"sourcesContent":["// Styles\nimport './VSlideGroup.sass'\n\n// Components\nimport { VFadeTransition } from '@/components/transitions'\nimport { VIcon } from '@/components/VIcon'\n\n// Composables\nimport { IconValue } from '@/composables/icons'\nimport { makeGroupProps, useGroup } from '@/composables/group'\nimport { makeTagProps } from '@/composables/tag'\nimport { useDisplay } from '@/composables'\nimport { useResizeObserver } from '@/composables/resizeObserver'\nimport { useRtl } from '@/composables/locale'\n\n// Utilities\nimport { computed, ref, watch } from 'vue'\nimport { clamp, genericComponent, IN_BROWSER, useRender } from '@/util'\nimport { bias, calculateCenteredOffset, calculateUpdatedOffset } from './helpers'\n\n// Types\nimport type { InjectionKey } from 'vue'\nimport type { SlotsToProps } from '@/util'\nimport type { GroupProvide } from '@/composables/group'\n\nexport const VSlideGroupSymbol: InjectionKey<GroupProvide> = Symbol.for('vuetify:v-slide-group')\n\ninterface SlideGroupSlot {\n  next: GroupProvide['next']\n  prev: GroupProvide['prev']\n  select: GroupProvide['select']\n  isSelected: GroupProvide['isSelected']\n}\n\nexport const VSlideGroup = genericComponent<new () => {\n  $props: SlotsToProps<{\n    default: [SlideGroupSlot]\n    prev: [SlideGroupSlot]\n    next: [SlideGroupSlot]\n  }>\n}>()({\n  name: 'VSlideGroup',\n\n  props: {\n    centerActive: Boolean,\n    direction: {\n      type: String,\n      default: 'horizontal',\n    },\n    symbol: {\n      type: null,\n      default: VSlideGroupSymbol,\n    },\n    nextIcon: {\n      type: IconValue,\n      default: '$next',\n    },\n    prevIcon: {\n      type: IconValue,\n      default: '$prev',\n    },\n    showArrows: {\n      type: [Boolean, String],\n      validator: (v: any) => (\n        typeof v === 'boolean' || [\n          'always',\n          'desktop',\n          'mobile',\n        ].includes(v)\n      ),\n    },\n\n    ...makeTagProps(),\n    ...makeGroupProps({\n      selectedClass: 'v-slide-group-item--active',\n    }),\n  },\n\n  emits: {\n    'update:modelValue': (value: any) => true,\n  },\n\n  setup (props, { slots }) {\n    const { isRtl } = useRtl()\n    const { mobile } = useDisplay()\n    const group = useGroup(props, props.symbol)\n    const isOverflowing = ref(false)\n    const scrollOffset = ref(0)\n    const containerSize = ref(0)\n    const contentSize = ref(0)\n    const isHorizontal = computed(() => props.direction === 'horizontal')\n\n    const { resizeRef: containerRef, contentRect: containerRect } = useResizeObserver()\n    const { resizeRef: contentRef, contentRect } = useResizeObserver()\n\n    const firstSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1\n\n      return group.items.value.findIndex(item => item.id === group.selected.value[0])\n    })\n\n    const lastSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1\n\n      return group.items.value.findIndex(item => item.id === group.selected.value[group.selected.value.length - 1])\n    })\n\n    if (IN_BROWSER) {\n      let frame = -1\n      watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {\n        cancelAnimationFrame(frame)\n        frame = requestAnimationFrame(() => {\n          if (containerRect.value && contentRect.value) {\n            const sizeProperty = isHorizontal.value ? 'width' : 'height'\n\n            containerSize.value = containerRect.value[sizeProperty]\n            contentSize.value = contentRect.value[sizeProperty]\n\n            isOverflowing.value = containerSize.value + 1 < contentSize.value\n          }\n\n          if (firstSelectedIndex.value >= 0 && contentRef.value) {\n            // TODO: Is this too naive? Should we store element references in group composable?\n            const selectedElement = contentRef.value.children[lastSelectedIndex.value] as HTMLElement\n\n            if (firstSelectedIndex.value === 0 || !isOverflowing.value) {\n              scrollOffset.value = 0\n            } else if (props.centerActive) {\n              scrollOffset.value = calculateCenteredOffset({\n                selectedElement,\n                containerSize: containerSize.value,\n                contentSize: contentSize.value,\n                isRtl: isRtl.value,\n                isHorizontal: isHorizontal.value,\n              })\n            } else if (isOverflowing.value) {\n              scrollOffset.value = calculateUpdatedOffset({\n                selectedElement,\n                containerSize: containerSize.value,\n                contentSize: contentSize.value,\n                isRtl: isRtl.value,\n                currentScrollOffset: scrollOffset.value,\n                isHorizontal: isHorizontal.value,\n              })\n            }\n          }\n        })\n      })\n    }\n\n    const disableTransition = ref(false)\n\n    let startTouch = 0\n    let startOffset = 0\n\n    function onTouchstart (e: TouchEvent) {\n      const sizeProperty = isHorizontal.value ? 'clientX' : 'clientY'\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1\n      startOffset = sign * scrollOffset.value\n      startTouch = e.touches[0][sizeProperty]\n      disableTransition.value = true\n    }\n\n    function onTouchmove (e: TouchEvent) {\n      if (!isOverflowing.value) return\n\n      const sizeProperty = isHorizontal.value ? 'clientX' : 'clientY'\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1\n      scrollOffset.value = sign * (startOffset + startTouch - e.touches[0][sizeProperty])\n    }\n\n    function onTouchend (e: TouchEvent) {\n      const maxScrollOffset = contentSize.value - containerSize.value\n\n      if (scrollOffset.value < 0 || !isOverflowing.value) {\n        scrollOffset.value = 0\n      } else if (scrollOffset.value >= maxScrollOffset) {\n        scrollOffset.value = maxScrollOffset\n      }\n\n      disableTransition.value = false\n    }\n\n    function onScroll () {\n      if (!containerRef.value) return\n\n      containerRef.value[isHorizontal.value ? 'scrollLeft' : 'scrollTop'] = 0\n    }\n\n    const isFocused = ref(false)\n    function onFocusin (e: FocusEvent) {\n      isFocused.value = true\n\n      if (!isOverflowing.value || !contentRef.value) return\n\n      // Focused element is likely to be the root of an item, so a\n      // breadth-first search will probably find it in the first iteration\n      for (const el of e.composedPath()) {\n        for (const item of contentRef.value.children) {\n          if (item === el) {\n            scrollOffset.value = calculateUpdatedOffset({\n              selectedElement: item as HTMLElement,\n              containerSize: containerSize.value,\n              contentSize: contentSize.value,\n              isRtl: isRtl.value,\n              currentScrollOffset: scrollOffset.value,\n              isHorizontal: isHorizontal.value,\n            })\n            return\n          }\n        }\n      }\n    }\n\n    function onFocusout (e: FocusEvent) {\n      isFocused.value = false\n    }\n\n    function onFocus (e: FocusEvent) {\n      if (\n        !isFocused.value &&\n        !(e.relatedTarget && contentRef.value?.contains(e.relatedTarget as Node))\n      ) focus()\n    }\n\n    function onKeydown (e: KeyboardEvent) {\n      if (!contentRef.value) return\n\n      if (isHorizontal.value) {\n        if (e.key === 'ArrowRight') {\n          focus(isRtl.value ? 'prev' : 'next')\n        } else if (e.key === 'ArrowLeft') {\n          focus(isRtl.value ? 'next' : 'prev')\n        }\n      } else {\n        if (e.key === 'ArrowDown') {\n          focus('next')\n        } else if (e.key === 'ArrowUp') {\n          focus('prev')\n        }\n      }\n\n      if (e.key === 'Home') {\n        focus('first')\n      } else if (e.key === 'End') {\n        focus('last')\n      }\n    }\n\n    function focus (location?: 'next' | 'prev' | 'first' | 'last') {\n      if (!contentRef.value) return\n\n      if (!location) {\n        const focusable = [...contentRef.value.querySelectorAll(\n          'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n        )].filter(el => !el.hasAttribute('disabled')) as HTMLElement[]\n        focusable[0]?.focus()\n      } else if (location === 'next') {\n        const el = contentRef.value.querySelector(':focus')?.nextElementSibling as HTMLElement | undefined\n        if (el) el.focus()\n        else focus('first')\n      } else if (location === 'prev') {\n        const el = contentRef.value.querySelector(':focus')?.previousElementSibling as HTMLElement | undefined\n        if (el) el.focus()\n        else focus('last')\n      } else if (location === 'first') {\n        (contentRef.value.firstElementChild as HTMLElement)?.focus()\n      } else if (location === 'last') {\n        (contentRef.value.lastElementChild as HTMLElement)?.focus()\n      }\n    }\n\n    function scrollTo (location: 'prev' | 'next') {\n      const newAbsoluteOffset = scrollOffset.value + (location === 'prev' ? -1 : 1) * containerSize.value\n\n      scrollOffset.value = clamp(newAbsoluteOffset, 0, contentSize.value - containerSize.value)\n    }\n\n    const contentStyles = computed(() => {\n      // This adds friction when scrolling the 'wrong' way when at max offset\n      let scrollAmount = scrollOffset.value > contentSize.value - containerSize.value\n        ? -(contentSize.value - containerSize.value) + bias(contentSize.value - containerSize.value - scrollOffset.value)\n        : -scrollOffset.value\n\n      // This adds friction when scrolling the 'wrong' way when at min offset\n      if (scrollOffset.value <= 0) {\n        scrollAmount = bias(-scrollOffset.value)\n      }\n\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1\n      return {\n        transform: `translate${isHorizontal.value ? 'X' : 'Y'}(${sign * scrollAmount}px)`,\n        transition: disableTransition.value ? 'none' : '',\n        willChange: disableTransition.value ? 'transform' : '',\n      }\n    })\n\n    const slotProps = computed(() => ({\n      next: group.next,\n      prev: group.prev,\n      select: group.select,\n      isSelected: group.isSelected,\n    }))\n\n    const hasAffixes = computed(() => {\n      switch (props.showArrows) {\n        // Always show arrows on desktop & mobile\n        case 'always': return true\n\n        // Always show arrows on desktop\n        case 'desktop': return !mobile.value\n\n        // Show arrows on mobile when overflowing.\n        // This matches the default 2.2 behavior\n        case true: return isOverflowing.value || Math.abs(scrollOffset.value) > 0\n\n        // Always show on mobile\n        case 'mobile': return (\n          mobile.value ||\n          (isOverflowing.value || Math.abs(scrollOffset.value) > 0)\n        )\n\n        // https://material.io/components/tabs#scrollable-tabs\n        // Always show arrows when\n        // overflowed on desktop\n        default: return (\n          !mobile.value &&\n          (isOverflowing.value || Math.abs(scrollOffset.value) > 0)\n        )\n      }\n    })\n\n    const hasPrev = computed(() => {\n      return Math.abs(scrollOffset.value) > 0\n    })\n\n    const hasNext = computed(() => {\n      // Check one scroll ahead to know the width of right-most item\n      return contentSize.value > Math.abs(scrollOffset.value) + containerSize.value\n    })\n\n    useRender(() => (\n      <props.tag\n        class={[\n          'v-slide-group',\n          {\n            'v-slide-group--vertical': !isHorizontal.value,\n            'v-slide-group--has-affixes': hasAffixes.value,\n            'v-slide-group--is-overflowing': isOverflowing.value,\n          },\n        ]}\n        tabindex={ (isFocused.value || group.selected.value.length) ? -1 : 0 }\n        onFocus={ onFocus }\n      >\n        { hasAffixes.value && (\n          <div\n            key=\"prev\"\n            class={[\n              'v-slide-group__prev',\n              { 'v-slide-group__prev--disabled': !hasPrev.value },\n            ]}\n            onClick={ () => scrollTo('prev') }\n          >\n            { slots.prev?.(slotProps.value) ?? (\n              <VFadeTransition>\n                <VIcon icon={ isRtl.value ? props.nextIcon : props.prevIcon }></VIcon>\n              </VFadeTransition>\n            ) }\n          </div>\n        ) }\n\n        <div\n          key=\"container\"\n          ref={ containerRef }\n          class=\"v-slide-group__container\"\n          onScroll={ onScroll }\n        >\n          <div\n            ref={ contentRef }\n            class=\"v-slide-group__content\"\n            style={ contentStyles.value }\n            onTouchstartPassive={ onTouchstart }\n            onTouchmovePassive={ onTouchmove }\n            onTouchendPassive={ onTouchend }\n            onFocusin={ onFocusin }\n            onFocusout={ onFocusout }\n            onKeydown={ onKeydown }\n          >\n            { slots.default?.(slotProps.value) }\n          </div>\n        </div>\n\n        { hasAffixes.value && (\n          <div\n            key=\"next\"\n            class={[\n              'v-slide-group__next',\n              { 'v-slide-group__next--disabled': !hasNext.value },\n            ]}\n            onClick={ () => scrollTo('next') }\n          >\n            { slots.next?.(slotProps.value) ?? (\n              <VFadeTransition>\n                <VIcon icon={ isRtl.value ? props.prevIcon : props.nextIcon }></VIcon>\n              </VFadeTransition>\n            ) }\n          </div>\n        ) }\n      </props.tag>\n    ))\n\n    return {\n      selected: group.selected,\n      scrollTo,\n      scrollOffset,\n      focus,\n    }\n  },\n})\n\nexport type VSlideGroup = InstanceType<typeof VSlideGroup>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}